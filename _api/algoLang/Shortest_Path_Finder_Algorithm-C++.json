{
  "mainALGO": "/**\n\tShortest path finder algorithm implementation\n\tFinds shortest distance to all vertices from given one vertex\n\tFast in practice\n\tWorks with negative cycles\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n\tint n, m;\n\tn = 5;\n\tm = 7;\n\n\tvector <pair <int, int> > g[n + 1];\n\tint a[] = {1, 1, 2, 3, 2, 1, 2};\n\tint b[] = {2, 3, 3, 4, 4, 5, 5};\n\tint c[] = {1, 4, 2, 8, 6, 7, 5};\n\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint v = a[i], u = b[i], w = c[i];\n\t\tg[v].push_back(make_pair(u, w));\n\t\tg[u].push_back(make_pair(v, w));\n\t}\n\n\tqueue <int> q;\n\tq.push(1);\n\n\tint d[n + 1];\n\tbool inQueue[n + 1];\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\td[i] = INT_MAX;\n\t\tinQueue[i] = false;\n\t}\n\n\td[1] = 0;\n\tinQueue[1] = true;\n\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\t// cerr << v << \" \";\n\t\tq.pop();\n\t\tinQueue[v] = false;\n\t\tfor (int i = 0; i < (int)g[v].size(); ++i) {\n\t\t\tint to = g[v][i].first, w = g[v][i].second;\n\t\t\tif (d[to] > d[v] + w) {\n\t\t\t\td[to] = d[v] + w;\n\t\t\t\tif (!inQueue[to]) {\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tinQueue[to] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tcout << d[i] << \" \";\n\n\treturn 0;\n}\n\n/**\n\tDistances array: 0 1 3 7 6\n*/\n"
}
