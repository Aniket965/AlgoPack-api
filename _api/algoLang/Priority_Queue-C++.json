{
  "mainALGO": "#include <iostream>\n#include <algorithm>\n\nstruct Leftist {\n  Leftist *left, *right;\n  // dis is the distance to the right-bottom side of the tree\n  int dis, value, size;\n  Leftist(int val = 0) {\n    left = NULL, right = NULL;\n    dis = 0, value = val, size = 1;\n  }\n  ~Leftist() {\n    delete left;\n    delete right;\n  }\n};\n\nLeftist* merge(Leftist *x, Leftist *y) {\n  // if x or y is NULL, return the other tree to be the answer\n  if (x == NULL) return y;\n  if (y == NULL) return x;\n\n  if (y->value < x->value) { // Use > here if you want a max priority queue\n    std::swap(x, y);\n  }\n\n  // We take x as new root, so add the size of y to x\n  x->size += y->size;\n\n  // merge the origin right sub-tree of x with y to construct the new right sub-tree of x\n  x->right = merge(x->right, y);\n\n  if (x->left == NULL && x->right != NULL) {\n    // if x->left is NULL pointer, swap the sub-trees to make it leftist\n    std::swap(x->left, x->right);\n  } else if(x->right != NULL && x->left->dis < x->right->dis) {\n    // if the distance of left sub-tree is smaller, swap the sub-trees to make it leftist\n    std::swap(x->left, x->right);\n  }\n\n  // calculate the new distance\n  if (x->right == NULL) {\n    x->dis = 0;\n  } else {\n    x->dis = x->right->dis + 1;\n  }\n  return x;\n}\n\nLeftist* delete_root(Leftist *T) {\n  //deleting root equals to make a new tree containing only left sub-tree and right sub-tree\n  Leftist *my_left = T->left;\n  Leftist *my_right = T->right;\n  T->left = T->right = NULL;\n  delete T;\n  return merge(my_left, my_right);\n}\n\nint main() {\n\n  Leftist *my_tree = new Leftist(10); // create a tree with root = 10\n\n  // adding a node to a tree is the same as creating a new tree and merge them together\n  my_tree = merge(my_tree, new Leftist(100));   // push 100\n  my_tree = merge(my_tree, new Leftist(10000)); // push 10000\n  my_tree = merge(my_tree, new Leftist(1));     // push 1\n  my_tree = merge(my_tree, new Leftist(1266));  // push 1266\n\n  while (my_tree != NULL) {\n    std::cout << my_tree->value << std::endl;\n    my_tree = delete_root(my_tree);\n  }\n\n  /* the output should be\n   * 1\n   * 10\n   * 100\n   * 1266\n   * 10000\n   */\n\n  return 0;\n}\n"
}
