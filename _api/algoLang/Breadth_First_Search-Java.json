{
  "mainALGO": "// Java program to print BFS traversal from a given source vertex.\n// BFS(int s) traverses vertices reachable from s.\nimport java.io.*;\nimport java.util.*;\n\n// This class represents a directed graph using adjacency list\n// representation\nclass Graph\n{\n    private int V;   // No. of vertices\n    private LinkedList<Integer> adj[]; //Adjacency Lists\n\n    // Constructor\n    Graph(int v)\n    {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    // Function to add an edge into the graph\n    void addEdge(int v,int w)\n    {\n        adj[v].add(w);\n    }\n\n    // prints BFS traversal from a given source s\n    void BFS(int s)\n    {\n        // Mark all the vertices as not visited(By default\n        // set as false)\n        boolean visited[] = new boolean[V];\n\n        // Create a queue for BFS\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n\n        // Mark the current node as visited and enqueue it\n        visited[s] = true;\n        queue.add(s);\n\n        while (queue.size() != 0)\n        {\n            // Dequeue a vertex from queue and print it\n            s = queue.poll();\n            System.out.print(s + \" \");\n\n            // Get all adjacent vertices of the dequeued vertex s\n            // If a adjacent has not been visited, then mark it\n            // visited and enqueue it\n            Iterator<Integer> i = adj[s].listIterator();\n            while (i.hasNext())\n            {\n                int n = i.next();\n                if (!visited[n])\n                {\n                    visited[n] = true;\n                    queue.add(n);\n                }\n            }\n        }\n    }\n\n\n    public static void main(String args[])\n    {\n        Graph g = new Graph(4);\n\n        g.addEdge(0, 1);\n        g.addEdge(0, 2);\n        g.addEdge(1, 2);\n        g.addEdge(2, 0);\n        g.addEdge(2, 3);\n        g.addEdge(3, 3);\n\n        System.out.println(\"Following is Breadth First Traversal \" + \"(starting from vertex 2)\");\n        g.BFS(2);\n    }\n}\n\n\n// OUTPUT\n// Following is Breadth First Traversal (starting from vertex 2)\n// 2 0 3 1\n"
}
ublic static void main(String arg[])\r\n    {\r\n        Node n1, n2, n3, n4, n5, n6, n7;\r\n        n1 = new Node(45);\r\n        n2 = new Node(27);\r\n        n3 = new Node(33);\r\n        n4 = new Node(55);\r\n        n5 = new Node(99);\r\n        n6 = new Node(84);\r\n        n7 = new Node(67);\r\n\r\n        list_of_nodes.add(n1);\r\n        list_of_nodes.add(n2);\r\n        list_of_nodes.add(n3);\r\n        list_of_nodes.add(n4);\r\n        list_of_nodes.add(n5);\r\n        list_of_nodes.add(n6);\r\n        list_of_nodes.add(n7);\r\n\r\n        int adjacency_matrix[][] = {\r\n                {0,1,1,0,0,0,0},  // Node 1: 45\r\n                {0,0,0,1,0,0,0},  // Node 2 :27\r\n                {0,1,0,1,1,1,0},  // Node 3: 33\r\n                {0,0,0,0,1,0,0},  // Node 4: 55\r\n                {0,0,0,0,0,0,1},  // Node 5: 99\r\n                {0,0,0,0,0,0,1},  // Node 6: 84\r\n                {0,0,0,0,0,0,0},  // Node 7: 67\r\n        };\r\n\r\n        System.out.println(\"Output\");\r\n        BreadthFirstSearch bfs = new BreadthFirstSearch();\r\n        bfs.bfs(adjacency_matrix, n1);\r\n    }\r\n}\r\n\r\n\r\n// Output:\r\n// 45\t27\t33\t55\t99\t84\t67\r\n"
}
