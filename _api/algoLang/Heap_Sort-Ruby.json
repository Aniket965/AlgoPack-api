{
  "mainALGO": "# NOTE: This kind of dynamic method addition to in-built classes is called\n#       MONKEY PATCHING(that's right) and its beautiful when done carefully\n#       This implementation does not factor in that safety.\n#\n#       Many suggest against monkey patching because it could turn into a\n#       nightmare in production due to the lack of concrete standard documentation\n#\n# REFERENCE THIS FOR TIPS\n# http://www.justinweiss.com/articles/3-ways-to-monkey-patch-without-making-a-mess/\n# HAPPY MONKEY PATCHING!\n\n# Public: In-Built Integer class override\n#         Extended Integer class methods to get the feel of how much a pseudo code\n#         can be related to interpreted code\n#         Methods are invoked on an integer\n#\n# Examples\n#\n#   10.parent\n#   => 5\n#   10.left\n#   => 20\n#   10.right\n#   => 21\nclass Integer\n  def parent\n    ( self / 2 ).floor\n  end\n\n  def left\n    ( 2 * self )\n  end\n\n  def right\n    ( 2 * self ) + 1\n  end\n\n  def half\n    ( self / 2 ).floor\n  end\nend\n\n# Public: In-Built Array class override\n#         Extended array class to add a method heap_size to be as close to the\n#         textbook as possible\n#\n# Examples\n#\n#   [1, 2, 3, 4].heap_size\n#   => nil\n#   [1, 2, 3, 4].heap_size = 10\n#   [1, 2, 3, 4].heap_size\n#   => 10\nclass Array\n  attr_accessor :heap_size\nend\n\n# Public: Ensures the max-heap property is being maintained from the index provided\n#         Recursive, Max-Heap property A[parent] >= A[left] as well as A[right]\n#\n# ARGS:\n# arr - Input array\n# i   - Index at which the Max-Heap property is to be applied\n#\n# RETURN: nil\n#\n# COMPLEXITY: Θ(lgn)\n#\n# Examples\n#    arr = [5, 3, 8, 7, 9, 6, 2, 4, 1]\n#    max_heapify(arr, 5)\n#\n# Modifies the provided array.\ndef max_heapify(arr, i)\n  arr.heap_size ||= arr.length\n\n  l = i.left\n  r = i.right\n\n  largest = (l <= arr.heap_size-1 && arr[l] > arr[i]) ? l : i\n  largest = r if (r <= arr.heap_size-1 && arr[r] > arr[largest])\n  if largest != i\n    arr[i], arr[largest] = arr[largest], arr[i]\n    max_heapify(arr, largest)\n  end\nend\n\n# Public: Ensures the min-heap property is being maintained from the index provided\n#         Recursive, Min-Heap property A[parent] <= A[left] as well as A[right]\n#\n# ARGS:\n# arr - Input array\n# i   - Index at which the Min-Heap property is to be applied\n#\n# RETURN: nil\n#\n# COMPLEXITY: Θ(lgn)\n#\n# Examples\n#    arr = [5, 3, 8, 7, 9, 6, 2, 4, 1]\n#    min_heapify(arr, 5)\n#\n# Modifies the provided array.\ndef min_heapify(arr, i)\n  arr.heap_size ||= arr.length\n\n  l = i.left\n  r = i.right\n\n  smallest = (l <= arr.heap_size-1 && arr[l] < arr[i]) ? l : i\n  smallest = r if (l <= arr.heap_size-1 && arr[l] < arr[smallest])\n  if smallest != i\n    arr[i], arr[smallest] = arr[smallest], arr[i]\n    min_heapify(arr, smallest)\n  end\nend\n\n# Public: Re-order the input array to adhere to the Max-Heap property at all indices\n#\n# ARGS:\n# arr - Input array\n#\n# RETURN: nil\n#\n# Examples\n#    arr = [5, 3, 8, 7, 9, 6, 2, 4, 1]\n#    build_max_heap(arr)\n#\n# Modifies the provided array.\ndef build_max_heap(arr)\n  arr.heap_size = arr.length\n  (0..arr.length.half).reverse_each do |i|\n    max_heapify(arr, i)\n  end\nend\n\n# Public: Sorts the array by adhering to the Max-Heap property and simulataneously\n#         decreasing the heap size\n#\n# ARGS:\n# arr - Input array\n#\n# RETURN: Array\n#\n# Examples\n#    arr = [5, 3, 8, 7, 9, 6, 2, 4, 1]\n#    heap_sort(arr)\n#    => [1, 2, 3, 4, 5, 6, 7, 8, 9]\n#\n# Modifies the provided array.\ndef heap_sort(arr)\n  build_max_heap(arr)\n  (1..(arr.length-1)).reverse_each do |i|\n    arr[0], arr[i] = arr[i], arr[0]\n    arr.heap_size -= 1\n    max_heapify(arr, 0)\n  end\n  arr\nend\n\ndef unit_test_heap_sort\n  arr = [5, 3, 8, 7, 9, 6, 2, 4, 1]\n  ok = (heap_sort(arr) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n  if ok\n    p \"HEAP SORT - OK\"\n  else\n    raise \"RESULT AND EXPECTED ARRAY DOES NOT MATCH\"\n  end\nend\n\nunit_test_heap_sort\n"
}
