{
  "mainALGO": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct node* ptrarr[1000005];\nlong long int vis[1000005];\n\nstruct node{\n        long long int value;\n        long long int weight;\n        struct node* next;\n};\n\nvoid adjinsert(struct node** head,long long int val,long long int weight){\n        struct node* first = (struct node*)malloc(sizeof(struct node));\n        first->value = val;\n        first->weight = weight;\n        first->next = *head;\n        *head = first;\n}\n\nstruct node arr[1000005];\nlong long int heapsize;\n\nvoid heapify(long long int i){\n        long long int left = arr[2*i].weight;\n        long long int right = arr[2*i+1].weight;\n        long long int root = arr[i].weight;\n        long long int lv = arr[2*i].value;\n        long long int rv = arr[2*i+1].value;\n        long long int mv = arr[i].value;\n\n        if(i>=1 && i<=heapsize && (2*i+1<=heapsize || 2*i<=heapsize )){\n                if( left <= right && left <= root){\n                        arr[i].weight = left;\n                        arr[i].value = lv;\n                        arr[2*i].weight = root;\n                        arr[2*i].value = mv;\n                        heapify(2*i);\n                }\n                else if( right < left && right < root){\n                        arr[i].weight = right;\n                        arr[i].value = rv;\n                        arr[2*i+1].weight = root;\n                        arr[2*i+1].value = mv;\n                        heapify(2*i+1);\n                }\n        }\n}\n\nvoid formHeap(){\n        long int i;\n        for(i=heapsize/2;i>=1;i--){\n                heapify(i);\n        }\n}\n\nvoid insert(long long int vertex, long long int val){\n        heapsize++;\n        arr[heapsize].weight = val;\n        arr[heapsize].value = vertex;\n        long long int parent = heapsize/2;\n        long long int child = heapsize;\n        while(arr[parent].weight > val && parent >= 1){\n                arr[child].weight = arr[parent].weight;\n                arr[parent].weight = val;\n                arr[child].value = arr[parent].value;\n                arr[parent].value = vertex;\n                child = parent;\n                parent = parent/2;\n        }\n        return;\n}\n\nstruct node pop(){\n        struct node poped;\n        poped.weight = arr[1].weight;\n        poped.value = arr[1].value;\n        arr[1].weight = arr[heapsize].weight;\n        arr[1].weight = arr[heapsize].weight;\n        arr[1].value = arr[heapsize].value;\n        arr[1].value = arr[heapsize].value;\n        heapsize--;\n        heapify(1);\n        return poped;\n}\n\nvoid print(){\n        long long int i;\n        printf(\"-------------------HEAP-----------------\\n\");\n        for(i=1;i<=heapsize;i++){\n                printf(\"v: %lld w: %lld \",arr[i].value, arr[i].weight);\n                printf(\"\\n\");\n        }\n        printf(\"----------------------------------------\\n\");\n}\n\nlong long int res,counter,spanedge;\nstruct node poped;\n\nlong long int prims(long long int v){\n        if(spanedge == counter)\n                return res;\n\n        struct node * current;\n        current = ptrarr[v];\n        while(current!=NULL){\n                if(vis[current->value]==0){\n                        insert(current->value,current->weight);\n                }\n                current = current->next;\n        }\n\n        poped = pop();\n        while(vis[poped.value]==1){\n                poped = pop();\n        }\n        res = res + poped.weight;\n        counter++;\n        vis[poped.value] = 1;\n        return prims(poped.value);\n}\n\nint main(){\n    long long int total,t,x,i,v,e,v1,v2,w;\n\n\tt = 1;\n\tsrand(time(NULL));\n\n        for(x=0;x<t;x++){\n                for(i=0;i<1000005;i++){\n                        ptrarr[i] = NULL;\n                        vis[i] = 0;\n                }\n\n                v = 5;\n\t\te = 10;\n\n                heapsize = 0;\n                total = 0;\n                spanedge = v-1;\n                res = 0;\n                counter = 0;\n\n                for(i=0;i<e;i++){\n\t\t\tv1 = (long long int) (rand() % v + 1);\n\t\t\tv2 = (long long int) (rand() % v + 1);\n\t\t\tw = (long long int) rand()%1000;\n                        if(v1!=v2){\n                                adjinsert(&ptrarr[v1],v2,w);\n                                adjinsert(&ptrarr[v2],v1,w);\n                        }\n                        total += w;\n                }\n\n                vis[1] = 1;\n                printf(\"Weight of minimum spanning tree : %lld\\n\", prims(1));\n        }\n\n\n        return 0;\n}\n"
}
