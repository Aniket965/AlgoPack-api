{
  "mainALGO": "// C++ program for implementation of Ford Fulkerson algorithm\n#include <iostream>\n#include <limits.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\n// Number of vertices in given graph\n#define V 6\n\n/* Returns true if there is a path from source 's' to sink 't' in\n  residual graph. Also fills parent[] to store the path */\nbool bfs(int rGraph[V][V], int s, int t, int parent[])\n{\n    // Create a visited array and mark all vertices as not visited\n    bool visited[V];\n    memset(visited, 0, sizeof(visited));\n\n    // Create a queue, enqueue source vertex and mark source vertex\n    // as visited\n    queue <int> q;\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n\n    // Standard BFS Loop\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n\n        for (int v = 0; v < V; v++)\n        {\n            if (visited[v]==false && rGraph[u][v] > 0)\n            {\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n\n    // If we reached sink in BFS starting from source, then return\n    // true, else false\n    return (visited[t] == true);\n}\n\n// Returns tne maximum flow from s to t in the given graph\nint fordFulkerson(int graph[V][V], int s, int t)\n{\n    int u, v;\n\n    // Create a residual graph and fill the residual graph with\n    // given capacities in the original graph as residual capacities\n    // in residual graph\n    int rGraph[V][V]; // Residual graph where rGraph[i][j] indicates\n    // residual capacity of edge from i to j (if there\n    // is an edge. If rGraph[i][j] is 0, then there is not) \n    for (u = 0; u < V; u++)\n        for (v = 0; v < V; v++)\n            rGraph[u][v] = graph[u][v];\n\n    int parent[V];//This array is filled by BFS and to store path\n\n    int max_flow = 0;//There is no flow initially\n\n    // Augment the flow while tere is path from source to sink\n    while (bfs(rGraph, s, t, parent))\n    {\n        // Find minimum residual capacity of the edhes along the\n        // path filled by BFS. Or we can say find the maximum flow\n        // through the path found.\n        int path_flow = INT_MAX;\n        for (v=t; v!=s; v=parent[v])\n        {\n            u = parent[v];\n            path_flow = min(path_flow, rGraph[u][v]);\n        }\n\n        // update residual capacities of the edges and reverse edges\n        // along the path\n        for (v=t; v != s; v=parent[v])\n        {\n            u = parent[v];\n            rGraph[u][v] -= path_flow;\n            rGraph[v][u] += path_flow;\n        }\n\n        // Add path flow to overall flow\n        max_flow += path_flow;\n    }\n\n    // Return the overall flow\n    return max_flow;\n}\n\n// Driver program to test above functions\nint main()\n{\n    // Let us create a graph shown in the above example\n    int graph[V][V] = { {0, 16, 13, 0, 0, 0},\n                        {0, 0, 10, 12, 0, 0},\n                        {0, 4, 0, 0, 14, 0},\n                        {0, 0, 9, 0, 0, 20},\n                        {0, 0, 0, 7, 0, 4},\n                        {0, 0, 0, 0, 0, 0}\n                      };\n\n    cout << \"The maximum possible flow is \" << fordFulkerson(graph, 0, 5);\n\n    return 0;\n}\n"
}
