{
  "mainALGO": "# THESE METHODS RESEMBLE CORMEN(CLRS) TEXTBOOK PSEUDO CODE\n\n# INDEX\n#      inorder_tree_walk\n#      preoder_tree_walk\n#      postorder_tree_walk\n#      tree_search\n#      iterative_tree_search\n#      tree_minimum\n#      tree_maximum\n#      tree_successor\n#      tree_insert\n#      tree_delete -> transplant\n\n# Public: Analogous to a struct in C/C++ for building linked lists.\n# This class only contains an initialize method which acts a constructor for\n# setting and accessing the object properties\n#\n# There are multiple ways this can be defined, this is my personal favorite\n# Other ways are listed at the bottom of the file\n# Choose whatever is convenient for YOU.\n#\n# Examples\n#   Tree.new(nil)\n#   # => #<Tree:0x007ffeab2187a0 @root=nil>\nclass Tree\n  attr_accessor :root\n\n  def initialize(root)\n    @root = root\n  end\nend\n\n# Public: Analogous to a struct in C/C++ for building linked lists.\n# This class only contains an initialize method which acts a constructor for\n# setting and accessing the object properties\n#\n# NOTE: Two constructors, one with satellite data and another without. The later\n#       one will be used predominantly\n#\n# Examples\n#   Node.new(10, \"HELLO\", nil, nil, nil)\n#   # => #<Node:0x007ffeab2187a0 @key=10, @satellite_data=\"HELLO\", @p=nil, @left=nil, @right=nil>\nclass Node\n  attr_accessor :key, :satellite_data, :p, :left, :right\n  def initialize(key, satellite_data, p, left, right)\n    @key, @satellite_data, @p, @left, @right = key, satellite_data, p, left, right\n  end\n\n  #   Node.new(10, nil, nil, nil)\n  #   # => #<Node:0x007ffeab2187a0 @key=10, @p=nil, @left=nil, @right=nil>\n  def initialize(key, p, left, right)\n    @key, @p, @left, @right = key, p, left, right\n  end\nend\n\n#             TREE structure\n#                  F\n#                /   \\\n#              B      G\n#            /  \\      \\\n#          A     D      I\n#              /  \\    /\n#             C   E   H\n#   tree = Tree.new(F)   NOTE: Whole tree is assumed to have been constructed alread\n\n# Public: Prints the elements inside tree nodes in a LEFT - PARENT - RIGHT manner\n#\n# x - Node, Preferably a root node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   inorder_tree_walk(F)\n#   => A B C D E F G H I\ndef inorder_tree_walk(x)\n  unless x.nil?\n    inorder_tree_walk(x.left)\n    p x.key\n    inorder_tree_walk(x.right)\n  end\nend\n\n# Public: Prints the elements inside tree nodes in a PARENT - LEFT - RIGHT manner\n#\n# x - Node, Preferably a root node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   preoder_tree_walk(F)\n#   => F B A D C E G I H\ndef preoder_tree_walk(x)\n  unless x.nil?\n    p x.key\n    preoder_tree_walk(x.left)\n    preoder_tree_walk(x.right)\n  end\nend\n\n# Public: Prints the elements inside tree nodes in a LEFT - RIGHT - PARENT manner\n#\n# x - Node, Preferably a root node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   postorder_tree_walk(F)\n#   => A C E D B H I G F\ndef postorder_tree_walk(x)\n  unless x.nil?\n    postorder_tree_walk(x.left)\n    postorder_tree_walk(x.right)\n    p x.key\n  end\nend\n\n# Public: Traverses and finds the element if present by using the Binary tree\n#         property - lesser elements on left and greater elements on right\n#         Recursive strategy\n#\n# x - Node, Preferably a root node\n# k - Key to be searched\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_search(F, 'I')\n#   => I\ndef tree_search(x, k)\n  return x if (x.nil? || k == x.key)\n  return (k < x.key) ? tree_search(x.left, k) : tree_search(x.right, k)\nend\n\n# Public: Traverses and finds the element if present by using the Binary tree\n#         property - lesser elements on left and greater elements on right\n#         Iterative strategy\n#\n# x - Node, Preferably a root node\n# k - Key to be searched\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_search(F, 'I')\n#   => I\ndef iterative_tree_search(x, k)\n  while !x.nil? && k != x.key\n    x = (k < x.key) ? x.left : x.right\n  end\n  x\nend\n\n# Public: Traverses to LEFT and finds the minimum element using the Binary tree\n#         property - lesser elements on left and greater elements on right\n#\n# Node, Root/Subtree node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_minimum(F)\n#   => A\ndef tree_minimum(x)\n  return if x.nil?\n  while !x.left.nil?\n    x = x.left\n  end\n  x\nend\n\n# Public: Traverses to RIGHT and finds the maximum element using the Binary tree\n#         property - lesser elements on left and greater elements on right\n#\n# Node, Root/Subtree node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_maximum(F)\n#   => H\ndef tree_maximum(x)\n  return if x.nil?\n  while !x.right.nil?\n    x = x.right\n  end\n  x\nend\n\n# Public: Finds the next biggest element to the given node in a Binary tree\n#\n# Node, Root/Subtree node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_successor(F)\n#   => G\ndef tree_successor(x)\n  return if x.nil?\n  return tree_minimum(x.right) unless x.right.nil?\n  y = x.p\n  while !y.nil? && x == y.right\n    x = y\n    y = y.p\n  end\n  y\nend\n\n# Public: Finds the highest element that is just smaller than the provided node\n#\n# Node, Root/Subtree node\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_predecessor(F)\n#   => E\ndef tree_predecessor(x)\n  return if x.nil?\n  return tree_maximum(x.left) unless x.left.nil?\n  y = x.p\n  while !y.nil? && x == y.left\n    x = y\n    y = y.p\n  end\n  y\nend\n\n# Public: Inserts a node at the appropriate location in the tree without not disturbing\n#         Binary search tree property\n#\n# t - Tree structure\n# z - Node to be INSERTED\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61\n#   tree_insert(t, J)\n#             TREE structure\n#                  F\n#                /   \\\n#              B      G\n#            /  \\      \\\n#          A     D      I\n#              /  \\   /  \\\n#             C   E  H    J(INSERTED NODE)\ndef tree_insert(t, z)\n  return if (t.nil? || z.nil?)\n  y = nil\n  x = t.root\n  while !x.nil?\n    y = x\n    (z.key < x.key) ? (x = x.left) : (x = x.right)\n  end\n  z.p = y\n\n  if y.nil?\n    t.root = z\n  elsif z.key < y.key\n    y.left = z\n  else\n    y.right = z\n  end\nend\n\n# Public: Replaces the subtree of a node with subtree of another node\n#\n# t - Tree structure\n# u - Node which gets replaced\n# v - Node which replaces u\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61 with an inserted node J\n#        transplant(t, G, I)\n#                F\n#              /   \\\n#             B     I\n#            / \\   / \\\n#           A   D H   J\n#              / \\\n#             C   E\ndef transplant(t, u, v)\n  return if (u.nil? || v.nil? || t.nil?)\n  if u.p.nil?\n    t.root = v\n  elsif u == u.p.left\n    u.p.left = v\n  else\n    u.p.right = v\n  end\n  v.p = u.p unless v.nil?\nend\n\n# Public: Deletes a node at the appropriate location in the tree without disturbing\n#         Binary search tree property\n# NOTE: Uses SUCCESSOR transplant i.e next largest element to the deletable node\n#\n# t - Tree structure\n# z - Node to be DELETED\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61 with an inserted node J\n#                        TREE structure\n#                                F\n#                              /   \\\n#                             B     G\n#                            / \\     \\\n#                           A   D     I\n#                              / \\   / \\\n#                             C   E H   J\n# tree_delete(t, F)        tree_delete(t, B)           tree_delete(t, D)\n#       G                        F                           F\n#     /   \\                    /   \\                       /   \\\n#    B     I                  C     G                     B     G\n#   / \\   / \\                / \\     \\                   / \\     \\\n#  A   D H   J              A   D     I                 A   E     I\n#     / \\                        \\   / \\                   /     / \\\n#    C   E                        E H   J                 C     H   J\ndef tree_delete(t, z)\n  return if z.nil?\n  if z.left.nil?\n    transplant(t, z, z.right)\n  elsif z.right.nil?\n    transplant(t, z, z.left)\n  else\n    y = tree_minimum(z.right)\n    if y.p != z\n      transplant(t, y, y.right)\n      y.right = z.right\n      y.right.p = y\n    end\n    transplant(t, z, y)\n    y.left = z.left\n    y.left.p = y\n  end\nend\n\n# Public: Deletes a node at the appropriate location in the tree without disturbing\n#         Binary search tree property\n# NOTE: Uses PREDECESSOR transplant i.e next largest element to the deletable node\n#\n# t - Tree structure\n# z - Node to be DELETED\n#\n# Examples\n#   NOTE: Based on the mock tree structure at LINE:61 with an inserted node J\n#                        TREE structure\n#                                F\n#                              /   \\\n#                             B     G\n#                            / \\     \\\n#                           A   D     I\n#                              / \\   / \\\n#                             C   E H   J\n# tree_delete(t, F)        tree_delete(t, B)           tree_delete(t, D)\n#       E                        F                           F\n#     /   \\                    /   \\                       /   \\\n#    B     G                  A     G                     B     G\n#   / \\     \\                  \\     \\                   / \\     \\\n#  A   D     I                  D     I                 A   C     I\n#     /     / \\                / \\   / \\                     \\   / \\\n#    C     H   J              C  E H   J                     E   H   J\ndef tree_delete_predecessor(t, z)\n  if z.left.nil?\n    transplant(t, z, z.right)\n  elsif z.right.nil?\n    transplant(t, z, z.left)\n  else\n    y = tree_maximum(z.left)\n    if y.p != z\n      transplant(t, y, y.left)\n      y.left = z.left\n      y.left.p = y\n    end\n    transplant(t, z, y)\n    y.right = z.right\n    y.right.p = y\n  end\nend\n\n# TEST inorder_tree_walk\n#      preoder_tree_walk\n#      postorder_tree_walk\n#      tree_search\n#      iterative_tree_search\n#      tree_minimum\n#      tree_maximum\n#      tree_successor\n#      tree_predecessor\n#      tree_insert\n#      tree_delete\n#      tree_delete_predecessor\ndef unit_test_binary_tree\n  node_a = Node.new('A', nil, nil, nil)\n  node_b = Node.new('B', nil, nil, nil)\n  node_c = Node.new('C', nil, nil, nil)\n  node_d = Node.new('D', nil, nil, nil)\n  node_e = Node.new('E', nil, nil, nil)\n  node_f = Node.new('F', nil, nil, nil)\n  node_g = Node.new('G', nil, nil, nil)\n  node_h = Node.new('H', nil, nil, nil)\n  node_i = Node.new('I', nil, nil, nil)\n  node_j = Node.new('J', nil, nil, nil)\n\n  tree = Tree.new(nil)\n\n  p \"--------------------  BEGIN CONSTRUCTING TREE -------------------- \"\n  [node_f, node_b, node_g, node_a, node_d, node_c, node_e, node_i, node_h].each_with_index do |x, i|\n    tree_insert(tree, x)\n  end\n  p \"                              F                      \"\n  p \"                            // \\\\                    \"\n  p \"                           B     G                   \"\n  p \"                         // \\\\    \\\\                 \"\n  p \"                         A   D     I                 \"\n  p \"                           // \\\\ //                  \"\n  p \"                           C   E H                   \"\n\n  p \"--------------------  END CONSTRUCTING TREE -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN INRODER TREE WALK -------------------- \"\n  p inorder_tree_walk(tree.root)\n  p \"--------------------  END INRODER TREE WALK -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN PREORDER TREE WALK -------------------- \"\n  p preoder_tree_walk(tree.root)\n  p \"--------------------  END PREORDER TREE WALK -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN POSTORDER TREE WALK -------------------- \"\n  p postorder_tree_walk(tree.root)\n  p \"--------------------  END PREORDER TREE WALK -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN RECURSIVE TREE SEARCH -------------------- \"\n  p tree_search(tree.root, 'I')\n  p \"--------------------  END RECURSIVE TREE SEARCH -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN ITERATIVE TREE SEARCH -------------------- \"\n  p iterative_tree_search(tree.root, 'I')\n  p \"--------------------  END ITERATIVETREE SEARCH -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN SEARCHING FOR TREE MIN -------------------- \"\n  p tree_minimum(tree.root)\n  p \"--------------------  END SEARCHING FOR TREE MIN -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN SEARCHING TREE MAX -------------------- \"\n  p tree_maximum(tree.root)\n  p \"--------------------  END SEARCHING TREE MAX -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN SEARCHING FOR SUCCESSOR -------------------- \"\n  p tree_successor(node_g)\n  p \"--------------------  END SEARCHING FOR SUCCESSOR -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN SEARCHING FOR PREDECESSOR -------------------- \"\n  p tree_predecessor(node_g)\n  p \"--------------------  END SEARCHING FOR PREDECESSOR -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN NODE INSERTION -------------------- \"\n  tree_insert(tree, node_j)\n  p \"                              F                      \"\n  p \"                            // \\\\                    \"\n  p \"                           B     G                   \"\n  p \"                         // \\\\    \\\\                 \"\n  p \"                         A   D     I                 \"\n  p \"                           // \\\\ // \\\\               \"\n  p \"                           C   E H   J               \"\n  p \"--------------------  END NODE INSERTION -------------------- \"\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN NODE DELETION (SUCCESSOR) -------------------- \"\n  tree_delete(tree, node_d)\n  p \"                              F                      \"\n  p \"                            // \\\\                    \"\n  p \"                           B     G                   \"\n  p \"                         // \\\\    \\\\                 \"\n  p \"                         A   E     I                 \"\n  p \"                           //    // \\\\               \"\n  p \"                           C     H   J               \"\n  p \"--------------------  END NODE DELETION (SUCCESSOR) -------------------- \"\n  preoder_tree_walk(tree.root)\n\n  print \"\\n\"\n\n  p \"--------------------  BEGIN NODE DELETION (PREDECESSOR) -------------------- \"\n  tree_delete_predecessor(tree, node_b)\n  p \"                              F                      \"\n  p \"                            // \\\\                    \"\n  p \"                           A     G                   \"\n  p \"                            \\\\    \\\\                 \"\n  p \"                             E     I                 \"\n  p \"                           //    // \\\\               \"\n  p \"                           C     H   J               \"\n  p \"--------------------  END NODE DELETION (PREDECESSOR) -------------------- \"\n  preoder_tree_walk(tree.root)\nend\n\n# Uncomment the lines below to run the minimal unit tests\nunit_test_binary_tree\n"
}
