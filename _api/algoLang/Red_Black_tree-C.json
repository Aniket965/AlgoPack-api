{
  "mainALGO": "#include <stdio.h>\n#include <stdlib.h>\n\n//CLRS \n//Insertion and Deletion in a Red Black Tree\nenum type {RED,BLACK};\n\nstruct Node\n{\n    int data;\n    struct Node* left;\n    struct Node* right;\n    struct Node* parent;\n    enum type color;\n};\n\n/*\n    Using Queue for level order traversal.\n    functions pfront, isempty, dequeue, enqueue are part of Queue implementation.\n\n*/\n\nstruct Queue\n{\n    struct Node* data;\n    struct Queue* next;\n};\n\nstruct Queue* front = NULL;\nstruct Queue* rear = NULL;\n\nstruct Node* pfront()\n{\n    struct Node* data ;\n    data = front->data;\n    return data;\n}\n\nint isempty()\n{\n    if(front==NULL)\n        return 1;\n\n    else\n        return 0;\n}\n\nvoid dequeue()\n{\n    if(isempty())\n        return ;\n\n    struct Queue* temp = front;\n    front = front->next;\n    free(temp);\n}\n\n\nvoid enqueue(struct Node* data)\n{\n    struct Queue* temp  =(struct Queue*)malloc(sizeof(struct Queue));\n    temp->data = data;\n    temp->next = NULL;\n\n    if(front==NULL && rear == NULL)\n    {\n        front = rear = temp;\n        return;\n    }\n\n    rear->next = temp;\n    rear = temp;\n}\n\nvoid levelorder(struct Node* root)\n{\n    if(root==NULL)\n        return;\n\n    enqueue(root);\n\n    while(!isempty())\n    {\n        struct Node* current = pfront();\n        printf(\"%d \",current->data);\n\n        if(current->left!=NULL)\n            enqueue(current->left);\n\n        if(current->right!=NULL)\n            enqueue(current->right);\n\n        dequeue();\n    }\n}\n\nvoid LeftRotate(struct Node** T,struct Node** x)\n{\n\n    /*\n        A left rotation looks like this.\n\n            x                               y\n          /   \\                           /   \\ \n         t1    y                         x     z\n              /  \\   ----->>>          /  \\   /  \\\n             t2   z                   t1  t2  t3  t4\n                 / \\\n                t3  t4\n\n    */\n\n\n    struct Node* y = (*x)->right;\n    (*x)->right = y->left;\n\n    if(y->left!=NULL)\n        y->left->parent = *x;\n\n    y->parent = (*x)->parent;\n\n    if((*x)->parent == NULL)\n        *T = y;\n\n    else if(*x == (*x)->parent->left)\n        (*x)->parent->left = y;\n\n    else\n        (*x)->parent->right = y;\n\n    y->left = *x;\n\n    (*x)->parent = y;\n\n}\nvoid RightRotate(struct Node** T,struct Node** x)\n{\n    /*\n        A right rotation looks like this.\n\n            x                            y\n           / \\                         /   \\ \n          y  t4                       z     x\n         / \\      ------>>>          / \\   / \\\n        z  t3                       t1 t2 t3 t4\n       / \\\n      t1  t2\n\n    */\n\n    struct Node* y = (*x)->left;\n    (*x)->left = y->right;\n\n    if(y->right!=NULL)\n        y->right->parent = *x;\n\n    y->parent = (*x)->parent;\n\n    if((*x)->parent==NULL)\n        *T = y;\n\n    else if((*x)== (*x)->parent->left)\n        (*x)->parent->left = y;\n\n    else\n        (*x)->parent->right = y;\n\n    y->right = *x;\n    (*x)->parent = y;\n\n}\n\nvoid RB_insert_fixup(struct Node** T, struct Node** z)\n{\n    // Parent and grandparent of deleted node.\n    struct Node* grandparent = NULL;\n    struct Node* parentpt = NULL;\n\n    while(((*z)!=*T)&& ((*z)->color!= BLACK) && ((*z)->parent->color == RED))\n    {\n        /*\n            In above while loop we check:\n            1.if inserted node is root node.. Then we just have to color it black.\n            2.we have to continue with while loop if property 2 is violated\n            (ie red parent cannot have red child.)\n\n        */\n        parentpt = (*z)->parent;\n        grandparent = (*z)->parent->parent;\n\n        if(parentpt == grandparent->left)\n        {\n            // If Node is inserted at left sub tree of grandparent.\n            struct Node* uncle = grandparent->right;\n\n            if(uncle!=NULL && uncle->color == RED)\n            {\n                /*\n                If uncle(other child node of parent node) is not NULL and is red.\n                1.color of grandparent is changed to Red.\n                2.color of grandparent is changed to Red.\n                3.uncle->color = BLACK;\n                */\n\n                grandparent->color = RED;\n                parentpt->color = BLACK;\n                uncle->color = BLACK;\n                *z = grandparent;\n                // We backtrack from z to grandparent.\n            }\n\n            else\n            {\n                // If inserted node is right child of parent.\n                if((*z) == parentpt->right)\n                {\n                    LeftRotate(T,&parentpt);\n                    (*z) = parentpt;\n                    parentpt = (*z)->parent;\n                }\n\n                RightRotate(T,&grandparent);\n                parentpt->color = BLACK;\n                grandparent->color = RED;\n                (*z) = parentpt;\n            }\n        }\n\n        else\n        {\n            // This is just opposite of If statement.\n            // ie. when parentpt is right child of grand parent.\n            struct Node* uncle = grandparent->left;\n\n            if(uncle!=NULL && uncle->color == RED)\n            {\n                grandparent->color = RED;\n                parentpt->color = BLACK;\n                uncle->color = BLACK;\n                (*z) = grandparent;\n            }\n\n            else\n            {\n                if((*z) == parentpt->left)\n                {\n                    RightRotate(T,&parentpt);\n                    (*z) = parentpt;\n                    parentpt = (*z)->parent;\n                }\n\n                LeftRotate(T,&grandparent);\n                parentpt->color = BLACK;\n                grandparent->color = RED;\n                (*z) = parentpt;\n            }\n        }\n    }\n    (*T)->color = BLACK;\n    // Root node is colored black.\n\n}\n\nstruct Node* RB_insert(struct Node* T,int data)\n{\n    struct Node* z = (struct Node*)malloc(sizeof(struct Node));\n    z->data = data;\n    z->left = NULL;\n    z->right = NULL;\n    z->parent = NULL;\n    z->color = RED;\n\n    struct Node* y = NULL;\n    struct Node* x = T;//root\n\n    while(x!=NULL)\n    {\n        y = x;\n        if(z->data < x->data)\n            x = x->left;\n\n        else\n            x = x->right;\n    }\n    z->parent = y;\n\n    if(y==NULL)\n        T = z;\n\n    else if(z->data < y->data)\n        y->left = z;\n\n    else\n        y->right = z;\n\n    // Normal Binary Search Tree Insertion till here.\n\n    /*\n    RB_insert_fixup is used to maintain Red Black Tree property.\n    Properties\n    1).Root must be black\n    2).Red parent cannot have red children(a red parent have both its children Black)\n    3).Every Node is either red or black\n    4).Black height of every node is same \n        ie. No of Black nodes from every leaf node to Root Node must be same.\n\n    */\n\n    RB_insert_fixup(&T,&z);\n\n    return T;\n}\n\nvoid preorder(struct Node* root)\n{\n    if(root==NULL)\n        return;\n\n    printf(\"%d \",root->data);\n    preorder(root->left);\n    preorder(root->right);\n}\n\nstruct Node* Tree_minimum(struct Node* node)\n{\n    //This function is used to find successor of node which we are trying to delete.\n    while(node->left!=NULL)\n        node = node->left;\n\n    return node;\n}\n\nvoid RB_delete_fixup(struct Node** T, struct Node** x)\n{\n    while((*x)!=*T && (*x)->color == BLACK)\n    {\n        if((*x)==(*x)->parent->left)\n        {\n            struct Node* w = (*x)->parent->right;\n\n            if(w->color==RED)\n            {\n                w->color = BLACK;\n                (*x)->parent->color = BLACK;\n                LeftRotate(T,&((*x)->parent));\n                w = (*x)->parent->right;\n            }\n\n            if(w->left->color==BLACK && w->right->color == BLACK)\n            {\n                w->color = RED;\n                (*x) = (*x)->parent;\n            }\n\n            else\n            {\n                if(w->right->color == BLACK)\n                {\n                    w->left->color = BLACK;\n                    w->color = RED;\n                    RightRotate(T,&w);\n                    w = (*x)->parent->right;\n                }\n\n                w->color = (*x)->parent->color;\n                (*x)->parent->color = BLACK;\n                w->right->color = BLACK;\n                LeftRotate(T,&((*x)->parent));\n                (*x) = *T;\n            }\n        }\n\n        else\n        {\n            struct Node* w = (*x)->parent->left;\n\n            if(w->color==RED)\n            {\n                w->color = BLACK;\n                (*x)->parent->color = BLACK;\n                RightRotate(T,&((*x)->parent));\n                w = (*x)->parent->left;\n            }\n\n            if(w->right->color==BLACK && w->left->color == BLACK)\n            {\n                w->color = RED;\n                (*x) = (*x)->parent;\n            }\n\n            else\n            {\n                if(w->left->color == BLACK)\n                {\n                    w->right->color = BLACK;\n                    w->color = RED;\n                    LeftRotate(T,&w);\n                    w = (*x)->parent->left;\n                }\n\n                w->color = (*x)->parent->color;\n                (*x)->parent->color = BLACK;\n                w->left->color = BLACK;\n                RightRotate(T,&((*x)->parent));\n                (*x) = *T;\n            }\n        }\n    }\n    (*x)->color = BLACK;\n\n}\n\nvoid RB_transplat(struct Node** T, struct Node** u,struct Node** v)\n{\n    if((*u)->parent == NULL)\n        *T = *v;\n\n    else if((*u)==(*u)->parent->left)\n        (*u)->parent->left = *v;\n    else\n        (*u)->parent->right = *v;\n\n    if((*v)!=NULL) \n        (*v)->parent = (*u)->parent;\n}\n\nstruct Node* RB_delete(struct Node *T,struct Node* z)\n{\n    /*\n    visit http://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\n    For the explanation.\n    */\n    struct Node *y = z;\n    enum type yoc;\n    yoc = z->color; // y's original color\n\n    struct Node* x;\n\n    if(z->left==NULL )\n    {\n        x = z->right;\n        RB_transplat(&T,&z,&(z->right));\n    }\n\n    else if(z->right==NULL )\n    {\n        x = z->left;\n        RB_transplat(&T,&z,&(z->left));\n    }\n\n    else\n    {\n        y = Tree_minimum(z->right);\n        yoc = y->color;\n        x = y->right;\n\n        if(y->parent==z)\n            x->parent = y;\n\n        else\n        {\n            RB_transplat(&T,&y,&(y->right));\n            y->right = z->right;\n            y->right->parent = y;\n        }\n\n        RB_transplat(&T,&z,&y);\n        y->left = z->left;\n        y->left->parent = y;\n        y->color = z->color;\n    }\n\n    if(yoc==BLACK)\n        RB_delete_fixup(&T,&x);\n\n    return T;\n}\n\nstruct Node* BST_search(struct Node* root, int x)\n{\n    if(root==NULL || root->data == x)\n        return root;\n\n    if(root->data > x)\n       return  BST_search(root->left,x);\n    else\n        return BST_search(root->right,x);\n}\n\nint main()\n{\n    struct Node* RBT = NULL;\n\n    RBT = RB_insert(RBT,2);\n    RBT = RB_insert(RBT,1);\n    RBT = RB_insert(RBT,4);\n    RBT = RB_insert(RBT,5);\n    RBT = RB_insert(RBT,9);\n    RBT = RB_insert(RBT,3);\n    RBT = RB_insert(RBT,6);\n    RBT = RB_insert(RBT,7);\n\n    printf(\"\\nPreorder - \");\n    preorder(RBT);\n\n    printf(\"\\nLevel order - \");\n    levelorder(RBT);\n\n    struct Node* x = BST_search(RBT,5);\n\n    RBT = RB_delete(RBT,x);\n\n    printf(\"\\nAfter deleting 5\");\n\n    printf(\"\\nPreorder - \");\n    preorder(RBT);\n\n    front = NULL; rear = NULL; // Delete old Queue\n\n    printf(\"\\nLevel order - \");\n    levelorder(RBT);\n\n    return 0;\n}\n\n\n/*\n                   2(b)\n                  /   \\\n                 1(b)  5(r)\n                       /    \\\n                     4(b)     7(b)\n                       /    /  \\\n                      3(r) 6(r)  9(r)\n\n\n                After deleting 5\n\n                   2(b)\n                  /   \\\n                 1(b)  6(r)\n                      /   \\\n                     4(b) 7(1)\n                     /     \\\n                    3(r)   9(r)\n\n*/\n\n/*\n\nOutput :\n\nPreorder - 2 1 5 4 3 7 6 9 \nLevel order - 2 1 5 4 7 3 6 9 \nAfter deleting 5\nPreorder - 2 1 6 4 3 7 9 \nLevel order - 2 1 6 4 7 3 9\n\n\n*/\n"
}
