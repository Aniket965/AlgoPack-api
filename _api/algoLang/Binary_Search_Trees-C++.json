{
  "mainALGO": "#include <iostream>\n#include <ios>\n#include <memory>\n#include <cassert>\n\nusing namespace std;\n\n// A set implemented using a binary search tree.\n// A binary search tree is a binary tree where the children on one side of a node are smaller and on the other side are larger. This makes searching in the tree efficient since only one of the two subtrees must be traversed for any visited node. However when sorted values are inserted, the tree degenerates into a linked list.\nclass int_set\n{\n  public:\n\tvoid insert( const int value )\n\t{\n\t\t_root = insert( move( _root ), value );\n\t}\n\n\tbool contains( const int value ) const\n\t{\n\t\treturn contains( _root, value );\n\t}\n\n\tvoid remove( const int value )\n\t{\n\t\t_root = remove( move( _root ), value );\n\t}\n\n\tvoid print() const\n\t{\n\t\tprint( 0, _root );\n\t}\n  private:\n\tstruct node;\n\tusing node_ptr = unique_ptr<node>;\n\tstruct node\n\t{\n\t\tint data = 0;\n\t\tnode_ptr left;\n\t\tnode_ptr right;\n\t};\n\n\tstatic node_ptr insert( node_ptr root, const int value );\n\tstatic bool contains( const node_ptr& root, const int value );\n\n\tstatic bool left_of( const node_ptr& root, const int value )\n\t{\n\t\treturn value < root->data;\n\t}\n\n\tstatic bool right_of( const node_ptr& root, const int value )\n\t{\n\t\treturn value > root->data;\n\t}\n\n\tstatic int leftmost( const node_ptr& root );\n\tstatic node_ptr remove( node_ptr root, const int value );\n\tstatic void print( const int indentation, const node_ptr& root );\n\n\tnode_ptr _root;\n};\n\n\n\nint_set::node_ptr int_set::insert( int_set::node_ptr root, const int value )\n{\n\tif ( root == nullptr )\n\t{\n\t\tauto newNode = make_unique<node>();\n\t\tnewNode->data = value;\n\t\treturn newNode;\n\t}\n\tif ( left_of( root, value ) )\n\t\troot->left = insert( move( root->left ), value );\n\telse if ( right_of( root, value ) )\n\t\troot->right = insert( move( root->right ), value );\n\treturn root;\n}\n\nbool int_set::contains( const int_set::node_ptr& root, const int value )\n{\n\tif ( root == nullptr )\n\t\treturn false;\n\tif ( left_of(root, value ) )\n\t\treturn contains( root->left, value );\n\tif ( right_of( root, value ) )\n\t\treturn contains( root->right, value );\n\treturn true;\n}\n\n\nint int_set::leftmost( const int_set::node_ptr& root )\n{\n\tassert( root != nullptr );\n\tif ( root->left != nullptr )\n\t\treturn leftmost( root->left );\n\treturn root->data;\n}\n\nint_set::node_ptr int_set::remove( int_set::node_ptr root, const int value )\n{\n\tif ( root == nullptr )\n\t\treturn root;\n\n\tif ( left_of( root, value ) )\n\t\troot->left = remove( move( root->left ), value );\n\telse if ( right_of( root, value ) )\n\t\troot->right = remove( move( root->right ), value );\n\telse\n\t{\n\t\t// must remove this node. Easy if left or right are empty...\n\t\tif ( root->left == nullptr )\n\t\t\treturn move( root->right );\n\t\tif( root->right == nullptr )\n\t\t\treturn move( root->left );\n\t\t// otherwise store the leftmost value from the right subtree here.\n\t\troot->data = leftmost( root->right );\n\t\troot->right = remove( move( root->right ), root->data );\n\t}\n\treturn root;\n}\n\nvoid int_set::print( const int indentation, const int_set::node_ptr& root )\n{\n\tfor ( int i = 0; i < indentation; ++i )\n\t\tcout << ' ';\n\n\tif ( root == nullptr )\n\t{\n\t\tcout << '*' << endl;\n\t\treturn;\n\t}\n\n\tcout << root->data << endl;\n\tprint( indentation + 1, root->left );\n\tprint( indentation + 1, root->right );\n}\n\nint main()\n{\n\tint_set s;\n\ts.insert( 5 );\n\ts.insert( 7 );\n\ts.insert( 9 );\n\ts.insert( 8 );\n\ts.insert( 6 );\n\ts.insert( 4 );\n\n\ts.print();\n\n\tcout << boolalpha; // print bools as true/false instead of 0/1\n\tcout << \"Contains 9: \" << s.contains( 9 ) << endl;\n\tcout << \"Contains 2: \" << s.contains( 2 ) << endl;\n\n\ts.remove( 7 );\n\ts.remove( 5 );\n\ts.remove( 4 );\n\n\tcout << \"Contains 9: \" << s.contains( 9 ) << endl;\n\tcout << \"Contains 2: \" << s.contains( 2 ) << endl;\n\tcout << \"Contains 5: \" << s.contains( 5 ) << endl;\n\tcout << \"Contains 6: \" << s.contains( 6 ) << endl;\n\n\ts.print();\n\treturn 0;\n}\n\n/* Output\n\n5\n 4\n  *\n  *\n 7\n  6\n   *\n   *\n  9\n   8\n    *\n    *\n   *\nContains 9: true\nContains 2: false\nContains 9: true\nContains 2: false\nContains 5: false\nContains 6: true\n6\n *\n 8\n  *\n  9\n   *\n   *\n*/\n"
}
