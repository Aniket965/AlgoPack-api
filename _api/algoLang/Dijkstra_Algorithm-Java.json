{
  "mainALGO": "package Greedy.Dijkstra;\r\n\r\nimport java.lang.*;\r\n// A Java program for Dijkstra's single source shortest path algorithm.\r\n// The program uses adjacency matrix\r\n    class Dijkstra\r\n    {\r\n\r\n        static final int V=9; //number of vertices\r\n        // A function to find the vertex with minimum distance value,\r\n        // from the set of vertices that aren't yet included in shortest path tree\r\n        void dj_algo(int graph[][], int source)\r\n        {\r\n            int distance[] = new int[V];\r\n            \r\n           \r\n            Boolean sptIncluded[] = new Boolean[V];\r\n            // Initializing all distances as INFINITE and stpIncluded[] as false\r\n            for (int i = 0; i < V; i++)\r\n            {\r\n                distance[i] = Integer.MAX_VALUE;\r\n                sptIncluded[i] = false;\r\n            }\r\n            distance[source] = 0;\r\n            // Shortest path\r\n            for (int count = 0; count < V-1; count++)\r\n            {\r\n                // Choose the vertex with smallest distance from unprocessed vertices\r\n                int u = minDistance(distance, sptIncluded);\r\n                // Mark the picked vertex as processed\r\n                sptIncluded[u] = true;\r\n                // Update distance value of the adjacent vertices of the picked vertex.\r\n                for (int v = 0; v < V; v++)\r\n                    // Update distance[v] only if it is not in sptIncluded,\r\n                    // there is an edge from u to v, and total distance(weight) from source to\r\n                    // v through u is smaller than current value of distance[v]\r\n                    // code courtesy Geeksforgeeks.org\r\n                    if (!sptIncluded[v] && graph[u][v]!=0 &&\r\n                            distance[u] != Integer.MAX_VALUE &&\r\n                            distance[u]+graph[u][v] < distance[v])\r\n                        distance[v] = distance[u] + graph[u][v];\r\n            }\r\n            // Generate the output\r\n            output(distance);\r\n        }\r\n        int minDistance(int distance[], Boolean sptIncluded[])\r\n        {\r\n            // Initialize minimum value\r\n            //Take the reference from Negative Infinity\r\n            //min_index corresponds to the index of\r\n            //vertex whose distance is stored in min\r\n            int min = Integer.MAX_VALUE, min_index=-1;\r\n            for (int v = 0; v < V; v++) {\r\n                if (sptIncluded[v] == false && distance[v] <= min) {\r\n                    min = distance[v];\r\n                    min_index = v;\r\n                }\r\n            }\r\n            return min_index;\r\n        }\r\n        void output(int distance[]){\r\n            System.out.println(\"Vertex\\tDistance From Source\");\r\n            for (int i = 0; i < V; i++) {\r\n                System.out.println(i + \"\\t\\t\\t\" + distance[i]);\r\n            }\r\n        }\r\n        // Driver method\r\n        public static void main (String[] args)\r\n        {\r\n        /* Example graph (adjacency matrix)*/\r\n        // courtesy Geeksforgeeks.org\r\n            int adj_matrix[][] = new int[][]{\r\n                    {0, 4, 0, 6, 0, 3, 0, 8, 0},\r\n                    {4, 0, 8, 0, 0, 0, 0, 7, 0},\r\n                    {0, 8, 0, 4, 0, 4, 0, 0, 2},\r\n                    {6, 0, 4, 0, 9, 5, 0, 0, 0},\r\n                    {0, 0, 0, 9, 0, 9, 0, 0, 0},\r\n                    {3, 0, 4, 5, 9, 0, 2, 0, 0},\r\n                    {0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n                    {8, 7, 0, 0, 0, 0, 1, 0, 7},\r\n                    {0, 0, 2, 0, 0, 0, 6, 7, 0}\r\n            };\r\n            System.out.println(\"Output\");\r\n            Dijkstra d = new Dijkstra();\r\n            d.dj_algo(adj_matrix, 0);\r\n        }\r\n    }\r\n// Output\r\n//        0\t\t0\r\n//        1\t\t4\r\n//        2\t\t7\r\n//        3\t\t6\r\n//        4\t\t12\r\n//        5\t\t3\r\n//        6\t\t5\r\n//        7\t\t6\r\n//        8\t\t9\r\n\r\n"
}
