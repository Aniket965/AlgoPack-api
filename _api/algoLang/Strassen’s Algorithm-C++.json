{
  "mainALGO": "    #include <assert.h>\n\n    #include <stdio.h>\n\n    #include <stdlib.h>\n\n    #include <time.h>\n\n     \n\n    #define M 2\n\n    #define N (1<<M)\n\n     \n\n    typedef double datatype;\n\n    #define DATATYPE_FORMAT \"%4.2g\"\n\n    typedef datatype mat[N][N]; // mat[2**M,2**M]  for divide and conquer mult.\n\n    typedef struct\n\n    {\n\n            int ra, rb, ca, cb;\n\n    } corners; // for tracking rows and columns.\n\n    // A[ra..rb][ca..cb] .. the 4 corners of a matrix.\n\n     \n\n    // set A[a] = I\n\n    void identity(mat A, corners a)\n\n    {\n\n        int i, j;\n\n        for (i = a.ra; i < a.rb; i++)\n\n            for (j = a.ca; j < a.cb; j++)\n\n                A[i][j] = (datatype) (i == j);\n\n    }\n\n     \n\n    // set A[a] = k\n\n    void set(mat A, corners a, datatype k)\n\n    {\n\n        int i, j;\n\n        for (i = a.ra; i < a.rb; i++)\n\n            for (j = a.ca; j < a.cb; j++)\n\n                A[i][j] = k;\n\n    }\n\n     \n\n    // set A[a] = [random(l..h)].\n\n    void randk(mat A, corners a, double l, double h)\n\n    {\n\n        int i, j;\n\n        for (i = a.ra; i < a.rb; i++)\n\n            for (j = a.ca; j < a.cb; j++)\n\n                A[i][j] = (datatype) (l + (h - l) * (rand() / (double) RAND_MAX));\n\n    }\n\n     \n\n    // Print A[a]\n\n    void print(mat A, corners a, char *name)\n\n    {\n\n        int i, j;\n\n        printf(\"%s = {\\n\", name);\n\n        for (i = a.ra; i < a.rb; i++)\n\n        {\n\n            for (j = a.ca; j < a.cb; j++)\n\n                printf(DATATYPE_FORMAT \", \", A[i][j]);\n\n            printf(\"\\n\");\n\n        }\n\n        printf(\"}\\n\");\n\n    }\n\n     \n\n    // C[c] = A[a] + B[b]\n\n    void add(mat A, mat B, mat C, corners a, corners b, corners c)\n\n    {\n\n        int rd = a.rb - a.ra;\n\n        int cd = a.cb - a.ca;\n\n        int i, j;\n\n        for (i = 0; i < rd; i++)\n\n        {\n\n            for (j = 0; j < cd; j++)\n\n            {\n\n                C[i + c.ra][j + c.ca] = A[i + a.ra][j + a.ca] + B[i + b.ra][j\n\n                        + b.ca];\n\n            }\n\n        }\n\n    }\n\n     \n\n    // C[c] = A[a] - B[b]\n\n    void sub(mat A, mat B, mat C, corners a, corners b, corners c)\n\n    {\n\n        int rd = a.rb - a.ra;\n\n        int cd = a.cb - a.ca;\n\n        int i, j;\n\n        for (i = 0; i < rd; i++)\n\n        {\n\n            for (j = 0; j < cd; j++)\n\n            {\n\n                C[i + c.ra][j + c.ca] = A[i + a.ra][j + a.ca] - B[i + b.ra][j\n\n                        + b.ca];\n\n            }\n\n        }\n\n    }\n\n     \n\n    // Return 1/4 of the matrix: top/bottom , left/right.\n\n    void find_corner(corners a, int i, int j, corners *b)\n\n    {\n\n        int rm = a.ra + (a.rb - a.ra) / 2;\n\n        int cm = a.ca + (a.cb - a.ca) / 2;\n\n        *b = a;\n\n        if (i == 0)\n\n            b->rb = rm; // top rows\n\n        else\n\n            b->ra = rm; // bot rows\n\n        if (j == 0)\n\n            b->cb = cm; // left cols\n\n        else\n\n            b->ca = cm; // right cols\n\n    }\n\n     \n\n    // Multiply: A[a] * B[b] => C[c], recursively.\n\n    void mul(mat A, mat B, mat C, corners a, corners b, corners c)\n\n    {\n\n        corners aii[2][2], bii[2][2], cii[2][2], p;\n\n        mat P[7], S, T;\n\n        int i, j, m, n, k;\n\n     \n\n        // Check: A[m n] * B[n k] = C[m k]\n\n        m = a.rb - a.ra;\n\n        assert(m==(c.rb-c.ra));\n\n        n = a.cb - a.ca;\n\n        assert(n==(b.rb-b.ra));\n\n        k = b.cb - b.ca;\n\n        assert(k==(c.cb-c.ca));\n\n        assert(m>0);\n\n     \n\n        if (n == 1)\n\n        {\n\n            C[c.ra][c.ca] += A[a.ra][a.ca] * B[b.ra][b.ca];\n\n            return;\n\n        }\n\n     \n\n        // Create the 12 smaller matrix indexes:\n\n        //  A00 A01   B00 B01   C00 C01\n\n        //  A10 A11   B10 B11   C10 C11\n\n        for (i = 0; i < 2; i++)\n\n        {\n\n            for (j = 0; j < 2; j++)\n\n            {\n\n                find_corner(a, i, j, &aii[i][j]);\n\n                find_corner(b, i, j, &bii[i][j]);\n\n                find_corner(c, i, j, &cii[i][j]);\n\n            }\n\n        }\n\n     \n\n        p.ra = p.ca = 0;\n\n        p.rb = p.cb = m / 2;\n\n     \n\n    #define LEN(A) (sizeof(A)/sizeof(A[0]))\n\n        for (i = 0; i < LEN(P); i++)\n\n            set(P[i], p, 0);\n\n     \n\n    #define ST0 set(S,p,0); set(T,p,0)\n\n     \n\n        // (A00 + A11) * (B00+B11) = S * T = P0\n\n        ST0;\n\n        add(A, A, S, aii[0][0], aii[1][1], p);\n\n        add(B, B, T, bii[0][0], bii[1][1], p);\n\n        mul(S, T, P[0], p, p, p);\n\n     \n\n        // (A10 + A11) * B00 = S * B00 = P1\n\n        ST0;\n\n        add(A, A, S, aii[1][0], aii[1][1], p);\n\n        mul(S, B, P[1], p, bii[0][0], p);\n\n     \n\n        // A00 * (B01 - B11) = A00 * T = P2\n\n        ST0;\n\n        sub(B, B, T, bii[0][1], bii[1][1], p);\n\n        mul(A, T, P[2], aii[0][0], p, p);\n\n     \n\n        // A11 * (B10 - B00) = A11 * T = P3\n\n        ST0;\n\n        sub(B, B, T, bii[1][0], bii[0][0], p);\n\n        mul(A, T, P[3], aii[1][1], p, p);\n\n     \n\n        // (A00 + A01) * B11 = S * B11 = P4\n\n        ST0;\n\n        add(A, A, S, aii[0][0], aii[0][1], p);\n\n        mul(S, B, P[4], p, bii[1][1], p);\n\n     \n\n        // (A10 - A00) * (B00 + B01) = S * T = P5\n\n        ST0;\n\n        sub(A, A, S, aii[1][0], aii[0][0], p);\n\n        add(B, B, T, bii[0][0], bii[0][1], p);\n\n        mul(S, T, P[5], p, p, p);\n\n     \n\n        // (A01 - A11) * (B10 + B11) = S * T = P6\n\n        ST0;\n\n        sub(A, A, S, aii[0][1], aii[1][1], p);\n\n        add(B, B, T, bii[1][0], bii[1][1], p);\n\n        mul(S, T, P[6], p, p, p);\n\n     \n\n        // P0 + P3 - P4 + P6 = S - P4 + P6 = T + P6 = C00\n\n        add(P[0], P[3], S, p, p, p);\n\n        sub(S, P[4], T, p, p, p);\n\n        add(T, P[6], C, p, p, cii[0][0]);\n\n     \n\n        // P2 + P4 = C01\n\n        add(P[2], P[4], C, p, p, cii[0][1]);\n\n     \n\n        // P1 + P3 = C10\n\n        add(P[1], P[3], C, p, p, cii[1][0]);\n\n     \n\n        // P0 + P2 - P1 + P5 = S - P1 + P5 = T + P5 = C11\n\n        add(P[0], P[2], S, p, p, p);\n\n        sub(S, P[1], T, p, p, p);\n\n        add(T, P[5], C, p, p, cii[1][1]);\n\n     \n\n    }\n\n    int main()\n\n    {\n\n        mat A, B, C;\n\n        corners ai = { 0, N, 0, N };\n\n        corners bi = { 0, N, 0, N };\n\n        corners ci = { 0, N, 0, N };\n\n        srand(time(0));\n\n        // identity(A,bi); identity(B,bi);\n\n        // set(A,ai,2); set(B,bi,2);\n\n        randk(A, ai, 0, 2);\n\n        randk(B, bi, 0, 2);\n\n        print(A, ai, \"A\");\n\n        print(B, bi, \"B\");\n\n        set(C, ci, 0);\n\n        // add(A,B,C, ai, bi, ci);\n\n        mul(A, B, C, ai, bi, ci);\n\n        print(C, ci, \"C\");\n\n        return 0;\n\n    }\n\nOutput:\n\n$ g++ StrassenMulitplication.cpp\n$ a.out\n \nA = {\n 1.2, 0.83, 0.39, 0.41, \n 1.8,  1.9, 0.49, 0.23, \n0.38, 0.72,  1.8,  1.9, \n0.13,  1.8, 0.48, 0.82, \n}\nB = {\n 1.2,  1.6,  1.4,  1.6, \n0.27, 0.63,  0.3, 0.79, \n0.58,  1.2,  1.1, 0.07, \n   2,  1.9, 0.47, 0.47, \n}\nC = {\n 2.7,  3.7,  2.6,  2.9, \n 3.4,    5,  3.7,  4.5, \n 5.3,  6.7,  3.6,  2.2, \n 2.5,  3.5,  1.6,  2.1, \n}\n"
}
