{
  "mainALGO": "                                                                      /*DESCRIPTION*/\n\n                                            /*Reusing precalculated results is nothing but Dynamic Programming*/\n/*In 0-1 Knapsack problem, WE are given a Knapsack (a kind of bag) and several items with their weight and profit. The bag has a maximum capacity of weight it can hold.\nNow your task is to maximise the profit by choosing several items. It is called 0-1 because of the decision values, either an item will be taken or it will be discarded.\nThe right approach to solve it is using DP (dynamic programming). Let the capacity of Knapsack be K, and there be N items, wt[]  be the array of weights and\nwt[i] be the weight of ith item; P[] be the array of profits and P[i] be the profit gained by ith item.\nNow you need to maximise Sigma (P[i]), take the sum as SUM. and constraint is Sigma (wt[i]) We can solve it using DP.*/\n\n                                                                  /*SOURCE CODE*/\n\n#include <iostream>\n\nusing namespace std;\n\nint max(int a, int b)              // A utility function that returns maximum of two integers\n{\n    return (a > b) ? a : b;\n}\n\nint knapSack(int K, int wt[], int P[], int n)               // Returns the maximum value that can be put in a knapsack of capacity W\n{\n    int i, w;\n    int DP[n + 1][K + 1];\n\n    for(i = 0; i <= n; i++)\n    {\n        for(w = 0; w <= K; w++)\n        {\n            if(i == 0 || w == 0)\n               DP[i][w] = 0;\n            else if(wt[i - 1] <= w)\n              DP[i][w] = max(P[i - 1] + DP[i - 1][w - wt[i - 1]], DP[i - 1][w]);\n            else\n              DP[i][w] = DP[i - 1][w];\n        }\n    }\n\n    return DP[n][K];\n}\n\nint knapSack_large(int K, int wt[], int P[], int n)\n{\n    int i, w;\n    int DP[2][K + 1];\n\n    for(i = 1; i <= K; i++)\n        DP[0][i] = 0;\n    DP[0][0] = 0;\n    DP[1][0] = 0;\n\n    for(i = 1; i <= n; i++)\n    {\n        for(w = 1; w <= K; w++)\n        {\n            if(wt[i - 1] <= w)\n                DP[i & 1][w] = max(P[i - 1] + DP[!(i & 1)][w - wt[i - 1]], DP[!(i & 1)][w]);\n            else\n                DP[i & 1][w] = DP[!(i & 1)][w];\n        }\n    }\n\n    return DP[n & 1][K];\n}\n\nint main()\n{\n    int P[] = {11, 22, 33, 44, 55};\n    int wt[] = {111, 121, 131, 141, 151};\n    int K = 300;\n    int n = sizeof(wt) / sizeof(wt[0]);\n\n\tcout << knapSack(K, wt, P, n);\n\n        cout << endl << \"Memory Optimised KnapSack \" << knapSack_large(K, wt, P, n);\n    return 0;\n}\n\n\n/* Output\n\n99\n\n*/\n"
}
