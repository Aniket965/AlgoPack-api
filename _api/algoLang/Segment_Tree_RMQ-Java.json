{
  "mainALGO": "class SegmentTreeRMQ\n{\n    int st[]; //array to store segment tree\n\n    // A utility function to get minimum of two numbers\n    int minVal(int x, int y) {\n        return (x < y) ? x : y;\n    }\n\n    // A utility function to get the middle index from corner\n    // indexes.\n    int getMid(int s, int e) {\n        return s + (e - s) / 2;\n    }\n\n    /*  A recursive function to get the minimum value in a given\n        range of array indexes. The following are parameters for\n        this function.\n\n        st    --> Pointer to segment tree\n        index --> Index of current node in the segment tree. Initially\n                   0 is passed as root is always at index 0\n        ss & se  --> Starting and ending indexes of the segment\n                     represented by current node, i.e., st[index]\n        qs & qe  --> Starting and ending indexes of query range */\n\n    int getSumUtil(int ss, int se, int qs, int qe, int si)\n    {\n        // If segment of this node is a part of given range, then return\n        // the sum of the segment\n        if (qs <= ss && qe >= se)\n            return st[si];\n\n        // If segment of this node is outside the given range\n        if (se < qs || ss > qe)\n            return 0;\n\n        // If a part of this segment overlaps with the given range\n        int mid = getMid(ss, se);\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n\n    /* A recursive function to update the nodes which have the given\n       index in their range. The following are parameters\n        st, si, ss and se are same as getSumUtil()\n        i    --> index of the element to be updated. This index is in\n                 input array.\n       diff --> Value to be added to all nodes which have i in range */\n    void updateValueUtil(int ss, int se, int i, int diff, int si)\n    {\n        // Base Case: If the input index lies outside the range of\n        // this segment\n        if (i < ss || i > se)\n            return;\n\n        // If the input index is in range of this node, then update the\n        // value of the node and its children\n        st[si] = st[si] + diff;\n        if (se != ss) {\n            int mid = getMid(ss, se);\n            updateValueUtil(ss, mid, i, diff, 2 * si + 1);\n            updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);\n        }\n    }\n\n    // The function to update a value in input array and segment tree.\n   // It uses updateValueUtil() to update the value in segment tree\n    void updateValue(int arr[], int n, int i, int new_val)\n    {\n        // Check for erroneous input index\n        if (i < 0 || i > n - 1) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n\n        // Get the difference between new value and old value\n        int diff = new_val - arr[i];\n\n        // Update the value in array\n        arr[i] = new_val;\n\n        // Update the values of nodes in segment tree\n        updateValueUtil(0, n - 1, i, diff, 0);\n    }\n\n    // Return sum of elements in range from index qs (quey start) to\n   // qe (query end).  It mainly uses getSumUtil()\n    int getSum(int n, int qs, int qe)\n    {\n        // Check for erroneous input values\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n\n\n    int RMQUtil(int ss, int se, int qs, int qe, int index)\n    {\n        // If segment of this node is a part of given range, then\n        // return the min of the segment\n        if (qs <= ss && qe >= se)\n            return st[index];\n\n        // If segment of this node is outside the given range\n        if (se < qs || ss > qe)\n            return Integer.MAX_VALUE;\n\n        // If a part of this segment overlaps with the given range\n        int mid = getMid(ss, se);\n        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1),\n                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2));\n    }\n\n    // Return minimum of elements in range from index qs (quey\n    // start) to qe (query end).  It mainly uses RMQUtil()\n    int RMQ(int n, int qs, int qe)\n    {\n        // Check for erroneous input values\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n\n        return RMQUtil(0, n - 1, qs, qe, 0);\n    }\n\n    // A recursive function that constructs Segment Tree for\n    // array[ss..se]. si is index of current node in segment tree st\n    int constructSTUtil(int arr[], int ss, int se, int si)\n    {\n        // If there is one element in array, store it in current\n        //  node of segment tree and return\n        if (ss == se) {\n            st[si] = arr[ss];\n            return arr[ss];\n        }\n\n        // If there are more than one elements, then recur for left and\n        // right subtrees and store the minimum of two values in this node\n        int mid = getMid(ss, se);\n        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1),\n                constructSTUtil(arr, mid + 1, se, si * 2 + 2));\n        return st[si];\n    }\n\n    /* Function to construct segment tree from given array. This function\n       allocates memory for segment tree and calls constructSTUtil() to\n       fill the allocated memory */\n    void constructST(int arr[], int n)\n    {\n        // Allocate memory for segment tree\n\n        //Height of segment tree\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n\n        //Maximum size of segment tree\n        int max_size = 2 * (int) Math.pow(2, x) - 1;\n        st = new int[max_size]; // allocate memory\n\n        // Fill the allocated memory st\n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n\n    // Driver program to test above functions\n    public static void main(String args[])\n    {\n        int arr[] = {1, 3, 2, 7, 9, 11};\n        int n = arr.length;\n        SegmentTreeRMQ tree = new SegmentTreeRMQ();\n\n        // Build segment tree from given array\n        tree.constructST(arr, n);\n\n        int qs = 1;  // Starting index of query range\n        int qe = 5;  // Ending index of query range\n\n        // Print minimum value in arr[qs..qe]\n        System.out.println(\"Minimum of values in range [\" + qs + \", \"\n                           + qe + \"] is = \" + tree.RMQ(n, qs, qe));\n    }\n}\n\n\n/* OUTPUT\nMinimum of values in range [1, 5] is = 2\n*/\n"
}
