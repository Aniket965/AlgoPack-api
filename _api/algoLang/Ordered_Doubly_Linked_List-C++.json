{
  "mainALGO": "#ifndef LIST_H\n#define LIST_H\n\nusing namespace std;\n\ntemplate<class T>\nclass List\n{\n    class Node{\n    public:\n        friend class List<T>;\n        T item{};\n        Node* next;\n        Node* prev;\n        Node(){ next = prev = nullptr; }\n        Node(T& item, Node* prev, Node* next){\n            this->item = item;\n            this->prev = prev;\n            this->next = next;\n        }\n    };\n    Node* first;\n    Node* last;\n    int size;\n    public:\n        List();\n        ~List();\n        bool emptyList();\n        void insertSingle (T& x);\n\n        void insertOrdered(T& item, int (*cmp)(const T& t1, const T& t2));\n        void deleteLast();\n\n        friend std::ostream& operator<< (std::ostream& out, List<T>& list){\n            Node *current= list.first;\n            while(current != nullptr){\n                out << current->item << endl;\n                current = current->next;\n            }\n            return out;\n        }\n        int size() {return size;}\n};\n\ntemplate<class T>\nList<T>::List(){\n    first = last = new Node();\n    size = 0;\n}\n\ntemplate<class T>\nList<T>::~List(){\n    Node* current = first;\n    while(first != nullptr){\n        first = first->next;\n        current->prev = current->next = nullptr;\n        delete current;\n        current = first;\n    }\n    size=0;\n}\n\ntemplate <class T>\nvoid List<T>::insertSingle (T& x) {\n    this->first=this->last=new Node(x, nullptr, nullptr);\n}\n\ntemplate <class T>\nbool List<T>::emptyList() {\n    return (this->size == 0);\n}\n\ntemplate <class T>\nvoid List<T>::insertOrdered (T& x, int (*cmp)(const T& t1, const T& t2)) {\n\n    if(emptyList()){\n        insertSingle(x);\n        this->size++;\n        return;\n    }\n\n    Node *temp = this->first;\n    Node* data = new Node(x, nullptr, nullptr);\n\n    while(temp!=nullptr){\n        if ((*cmp)(x,(temp->item))>0){\n            if (temp->prev==nullptr){\n                data->prev=nullptr;\n                this->first=data;\n                data->next=temp;\n                temp->prev=data;\n                size++;\n                return;\n            }\n            else{\n                data->next=temp;\n                data->prev=temp->prev;\n                temp->prev->next=data;\n                temp->prev=data;\n                size++;\n                return;\n            }\n        }\n        else if (temp->next==nullptr){\n            temp->next=data;\n            data->prev=temp;\n            data->next=nullptr;\n            this->last=data;\n            size++;\n            return;\n        }\n        temp=temp->next;\n    }\n}\n\ntemplate <class T>\nvoid List<T>::deleteLast () {\n    if (emptyList())\n        return;\n\n    Node *current = this->last;\n    Node *current1 = current->prev;\n    current1->next = nullptr;\n\n    delete current;\n    this->last = aux1;\n    size--;\n}\n\n#endif // LIST_H\n"
}
