{
  "mainALGO": "//JAVA program for implementation of Ford Fulkerson algorithm\n// code courtesy Geeksforgeeks.org\nimport java.util.LinkedList;\n\n\nclass Ford_Fulkerson_Method {\n\n  //Number of vertices in graph\n  static final int V = 6;\n\n  /* Returns true if there is a path from source 's' to sink\n    't' in residual graph. Also fills parent[] to store the\n    path */\n  boolean bfs(int rGraph[][], int s, int t, int parent[])\n  {\n      // Create a visited array and mark all vertices as not\n      // visited\n      boolean visited[] = new boolean[V];\n      for(int i=0; i<V; ++i)\n          visited[i]=false;\n\n      // Create a queue, enqueue source vertex and mark\n      // source vertex as visited\n      LinkedList<Integer> queue = new LinkedList<Integer>();\n      queue.add(s);\n      visited[s] = true;\n      parent[s]=-1;\n\n      // Standard BFS Loop\n      while (queue.size()!=0)\n      {\n          int u = queue.poll();\n\n          for (int v=0; v<V; v++)\n          {\n              if (visited[v]==false && rGraph[u][v] > 0)\n              {\n                  queue.add(v);\n                  parent[v] = u;\n                  visited[v] = true;\n              }\n          }\n      }\n\n      // If we reached sink in BFS starting from source, then\n      // return true, else false\n      return (visited[t] == true);\n  }\n//Returns tne maximum flow from s to t in the given graph\n  int fordFulkerson(int graph[][], int s, int t)\n  {\n      int u, v;\n\n      // Create a residual graph and fill the residual graph\n      // with given capacities in the original graph as\n      // residual capacities in residual graph\n\n      // Residual graph where rGraph[i][j] indicates\n      // residual capacity of edge from i to j (if there\n      // is an edge. If rGraph[i][j] is 0, then there is\n      // not)\n      int rGraph[][] = new int[V][V];\n\n      for (u = 0; u < V; u++)\n          for (v = 0; v < V; v++)\n              rGraph[u][v] = graph[u][v];\n\n      // This array is filled by BFS and to store path\n      int parent[] = new int[V];\n\n      int max_flow = 0;  // There is no flow initially\n\n      // Augment the flow while tere is path from source\n      // to sink\n      while (bfs(rGraph, s, t, parent))\n      {\n          // Find minimum residual capacity of the edhes\n          // along the path filled by BFS. Or we can say\n          // find the maximum flow through the path found.\n          int path_flow = Integer.MAX_VALUE;\n          for (v=t; v!=s; v=parent[v])\n          {\n              u = parent[v];\n              path_flow = Math.min(path_flow, rGraph[u][v]);\n          }\n\n          // update residual capacities of the edges and\n          // reverse edges along the path\n          for (v=t; v != s; v=parent[v])\n          {\n              u = parent[v];\n              rGraph[u][v] -= path_flow;\n              rGraph[v][u] += path_flow;\n          }\n\n          // Add path flow to overall flow\n          max_flow += path_flow;\n      }\n\n      // Return the overall flow\n      return max_flow;\n  }\n\n  // Driver program to test above functions\n  public static void main (String[] args) throws java.lang.Exception\n  {\n      // Let us create a graph shown in the above example\n      int graph[][] =new int[][] { {0, 16, 13, 0, 0, 0},\n                                   {0, 0, 10, 12, 0, 0},\n                                   {0, 4, 0, 0, 14, 0},\n                                   {0, 0, 9, 0, 0, 20},\n                                   {0, 0, 0, 7, 0, 4},\n                                   {0, 0, 0, 0, 0, 0}\n                                 };\n      Ford_Fulkerson_Method m = new Ford_Fulkerson_Method();\n\n      System.out.println(\"The maximum possible flow is \" +\n                         m.fordFulkerson(graph, 0, 5));\n\n  }\n\n\n}\n/* Output\n\nThe maximum possible flow is 23\n\n\n\n*/\n"
}
