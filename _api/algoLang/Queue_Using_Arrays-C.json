{
  "mainALGO": "// C program for array implementation of queue\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n// A structure to represent a queue\ntypedef struct Queue\n{\n\tint front, rear, size;\n\tunsigned capacity;\n\tint* array;\n}Queue;\n\n\nQueue* createQueue(unsigned capacity)\n{\n\tQueue* queue = (Queue*) malloc(sizeof(Queue));\n\tqueue->capacity = capacity;\n\tqueue->front = queue->size = 0;\n\tqueue->rear = capacity - 1; // This is important, see the enqueue\n\tqueue->array = (int*) malloc(queue->capacity * sizeof(int));\n\treturn queue;\n}\n\n\nint isFull(Queue* queue)\n{ return (queue->size == queue->capacity); }\n\nint isEmpty(Queue* queue)\n{ return (queue->size == 0); }\n\nvoid enqueue(Queue* queue, int item)\n{\n\tif (isFull(queue))\n\t\treturn;\n\tqueue->rear = (queue->rear + 1)%queue->capacity;\n\tqueue->array[queue->rear] = item;\n\tqueue->size = queue->size + 1;\n\tprintf(\"%d enqueued to queue\\n\", item);\n}\nint dequeue(Queue* queue)\n{\n\tif (isEmpty(queue))\n\t\treturn INT_MIN;\n\tint item = queue->array[queue->front];\n\tqueue->front = (queue->front + 1)%queue->capacity;\n\tqueue->size = queue->size - 1;\n\treturn item;\n}\n\nint front(Queue* queue)\n{\n\tif (isEmpty(queue))\n\t\treturn INT_MIN;\n\treturn queue->array[queue->front];\n}\nint rear(Queue* queue)\n{\n\tif (isEmpty(queue))\n\t\treturn INT_MIN;\n\treturn queue->array[queue->rear];\n}\n\nint main()\n{\n\t Queue* queue = createQueue(1000);\n\n\tenqueue(queue, 5);\n\tenqueue(queue, 7);\n\tenqueue(queue, 23);\n\tenqueue(queue, 67);\n\n\tprintf(\"%d dequeued from queue\\n\", dequeue(queue));\n\n\tprintf(\"Front item is %d\\n\", front(queue));\n\tprintf(\"Rear item is %d\\n\", rear(queue));\n\n\treturn 0;\n}\n//output\n/*\n5 enqueued to queue\n7 enqueued to queue\n23 enqueued to queue\n67 enqueued to queue\n5 dequeued from queue\nFront item is 7\nRear item is 67\n*/\n"
}
