{
  "mainALGO": "//for directed acyclig graphs!!\n\n#include<stdio.h>\n#include<stdlib.h>\n#define INF 999999\ntypedef struct node graph;\nstruct node{\n\tint val;\n\tgraph *next;\n\tint weight;\n};\nint src;\nint wt_ans,val_ans;\nint heap_count;\nint flag[1000000];\nstruct node table[1000000];\nstruct node a[1000000];\n\nvoid insert_vertex(int n){\n\tint i;\n\tfor(i=1;i<=n;i++){\n\t\ttable[i].next=NULL;\n\t\ttable[i].weight=0;\t\n\t}\n}\n\nvoid insert_edge(int x,int y,int w){\n\tgraph *one;\n\tone=(graph*)malloc(sizeof(graph));\n\tone->val=y;\n\tone->weight=w;\n\tone->next=NULL;\n\tgraph *tmp;\n\tif(table[x].next==NULL){\n\t\ttable[x].next=one;\n\t}\n\telse{\n\t\ttmp=table[x].next;\n\t\twhile(tmp->next!=NULL){\n\t\t\ttmp=tmp->next;\n\t\t}\n\t\ttmp->next=one;\n\t}\n}\nvoid insert_heap(int n){\n\tint l,i;\n\tfor(i=1;i<=n;i++){\n\t\ta[i].weight=INF;\n\t\ta[i].val=i;\n\t}\n}\n\nvoid update_heap(int x,int y){\n\tgraph tmp;\n\tint l,k;\n\tint i;\n\tif(x==src && x!=1){\n\t\ttmp=a[1];\n\t\ta[1]=a[x];\n\t\ta[x]=tmp;\n\t\ta[1].weight=y;\n\t}\n\telse if(x!=src){\n\t\tfor(i=1;i<=heap_count;i++){\n\t\t\tif(a[i].val==x){\n\t\t\t\tk=i;\n\t\t\t\ta[k].weight=y;\n\t\t\t}\n\t\t}\n\t\twhile((a[k/2].weight>a[k].weight)&&(k/2>=1)){\n\t\t\ttmp=a[k/2];\n\t\t\ta[k/2]=a[k];\n\t\t\ta[k]=tmp;\n\t\t\tk=k/2;\n\t\t}\n\t}\n/*\tint b;\n\tfor(b=1;b<=heap_count;b++){\n\t\tprintf(\"val(%d),wt(%d)\\n\",a[b].val,a[b].weight);\n\t}\n\tprintf(\"Updated_root=%d with %d\\n\",a[1].val,a[1].weight);\n*/}\n\nvoid extract_heap(int z){\n\tgraph tmp;\n\tgraph var;\n\ttmp=a[1];\n//\tprintf(\"NOW ROOT=%d\\n\",tmp.val);\n\tval_ans=tmp.val;\n\twt_ans=tmp.weight;\n\tflag[a[1].val]=1;\n\ta[1]=a[z];\n\theap_count--;\n\tint k=1;\n\twhile((a[k].weight>a[2*k].weight || a[k].weight > a[2*k+1].weight) && (2*k<=z)){\n\t\tif((a[k].weight>a[2*k].weight) && (a[k].weight <= a[2*k+1].weight)){\n\t\t\tvar=a[2*k];\n\t\t\ta[2*k]=a[k];\n\t\t\ta[k]=var;\n\t\t\tk=2*k;\n\n\t\t}\n\t\telse{\n\t\t\tvar=a[2*k+1];\n\t\t\ta[2*k+1]=a[k];\n\t\t\ta[k]=var;\n\t\t\tk=2*k+1;\n\t\t}\n\t}\n}\t\n\nint check_heap(int x){\n\tint i,y;\n\tfor(i=1;i<=heap_count;i++){\n\t\tif(a[i].val==x){\n\t\t\ty=a[i].weight;\n\t\t}\n\t}\n\treturn y;\n}\nvoid print_table(int n){\n\tgraph *tmp,*var;\n\tint i,j;\n\tfor(i=1;i<=n;i++){\n\t\tprintf(\"table[%d]\",i);\n\t\ttmp=table[i].next;\n\t\twhile(tmp){\n\t\t\tprintf(\"->%d\",tmp->val);\n\t\t\ttmp=tmp->next;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main(){\n\tint n,x,y,w,m;\n\tint t;\n\tint v1,v2;\n\tgraph *tmp;\n\tgraph *var,*tmp2;\n\t//scanf(\"%d%d\",&n,&m);\n\tn=4;\n\tm=4;\n\tinsert_vertex(n); //  n=4 \n\tint i,j,k,l;\n\theap_count=n;\n\tfor(i=1;i<=n;i++){\n\t\tflag[i]=0;\n\t}\n\t// for(i=0;i<m;i++){\n\t// \tscanf(\"%d%d%d\",&x,&y,&w);\n\t// \tinsert_edge(x,y,w);\n\t// }\n\t \t\n\t \t//Input:\n\t \tinsert_edge(1,2,24);\n\t \tinsert_edge(1,4,20);\n\t \tinsert_edge(3,1,3);\n\t \tinsert_edge(4,3,12);\n\n// In case want to see how the adjecency table gets created uncomment the print_table function below.\t\n//print_table(n);\n\tinsert_heap(n);\n\tint src,dest;\n\t// scanf(\"%d\",&src);\n\tsrc=1;\n\tupdate_heap(src,0);\n\twhile(heap_count>0){\n\t\textract_heap(heap_count);\n//\t\tprintf(\"Extracted=%d\\n\",val_ans);\n\t\tv1=val_ans;\n\t\ttable[v1].weight=wt_ans;\n\t\ttmp2=table[v1].next;\n\t\twhile(tmp2){\n\t\t\tvar=tmp2;\n\t\t\tif(flag[var->val]==0){\n\t\t\t\tv2=check_heap(var->val);\n\t\t\t\tif(var->weight+table[v1].weight < v2){\n\t\t\t\t\tupdate_heap(var->val,(var->weight+table[v1].weight));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp2=tmp2->next;\n\t\t}\n\t}\n\tint q;\n\tfor(q=1;q<=n;q++){\n\t\tprintf(\"%d to %d = %d\\n\",src ,q,table[q].weight);\n\t}\n\treturn 0;\n}\n//Output:\n// 1 to 1 = 0\n// 1 to 2 = 24\n// 1 to 3 = 32\n// 1 to 4 = 20"
}
