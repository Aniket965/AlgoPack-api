{
  "mainALGO": "/******************************************************************************\n *\n *  A generic queue, implemented using a singly-linked list.\n *  Reference:  http://algs4.cs.princeton.edu/13stacks/Queue_Linked_List.java.html\n *\n *\n ******************************************************************************/\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\n/**\n *  This implementation uses a singly-linked list with a non-static nested class\n *  for linked-list nodes.  See {@link Queue} for a version that uses a static nested class.\n *  The <em>enqueue</em>, <em>dequeue</em>, <em>peek</em>, <em>size</em>, and <em>is-empty</em>\n *  operations all take constant time in the worst case.\n *  <p>\n */\npublic class Queue_Linked_List<Item> implements Iterable<Item> {\n    private int n;         // number of elements on queue\n    private Node first;    // beginning of queue\n    private Node last;     // end of queue\n\n    // helper linked list class\n    private class Node {\n        private Item item;\n        private Node next;\n    }\n\n    /**\n     * Initializes an empty queue.\n     */\n    public Queue_Linked_List() {\n        first = null;\n        last  = null;\n        n = 0;\n        assert check();\n    }\n\n    /**\n     * Is this queue empty?\n     * @return true if this queue is empty; false otherwise\n     */\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    /**\n     * Returns the number of items in this queue.\n     * @return the number of items in this queue\n     */\n    public int size() {\n        return n;\n    }\n\n    /**\n     * Returns the item least recently added to this queue.\n     * @return the item least recently added to this queue\n     * @throws java.util.NoSuchElementException if this queue is empty\n     */\n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        return first.item;\n    }\n\n    /**\n     * Adds the item to this queue.\n     * @param item the item to add\n     */\n    public void enqueue(Item item) {\n        Node oldlast = last;\n        last = new Node();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n        assert check();\n    }\n\n    /**\n     * Removes and returns the item on this queue that was least recently added.\n     * @return the item on this queue that was least recently added\n     * @throws java.util.NoSuchElementException if this queue is empty\n     */\n    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   // to avoid loitering\n        assert check();\n        return item;\n    }\n\n    /**\n     * Returns a string representation of this queue.\n     * @return the sequence of items in FIFO order, separated by spaces\n     */\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this)\n            s.append(item + \" \");\n        return s.toString();\n    }\n\n    // check internal invariants\n    private boolean check() {\n        if (n < 0) {\n            return false;\n        }\n        else if (n == 0) {\n            if (first != null) return false;\n            if (last  != null) return false;\n        }\n        else if (n == 1) {\n            if (first == null || last == null) return false;\n            if (first != last)                 return false;\n            if (first.next != null)            return false;\n        }\n        else {\n            if (first == null || last == null) return false;\n            if (first == last)      return false;\n            if (first.next == null) return false;\n            if (last.next  != null) return false;\n\n            // check internal consistency of instance variable n\n            int numberOfNodes = 0;\n            for (Node x = first; x != null && numberOfNodes <= n; x = x.next) {\n                numberOfNodes++;\n            }\n            if (numberOfNodes != n) return false;\n\n            // check internal consistency of instance variable last\n            Node lastNode = first;\n            while (lastNode.next != null) {\n                lastNode = lastNode.next;\n            }\n            if (last != lastNode) return false;\n        }\n\n        return true;\n    }\n\n\n    /**\n     * Returns an iterator that iterates over the items in this queue in FIFO order.\n     * @return an iterator that iterates over the items in this queue in FIFO order\n     */\n    public Iterator<Item> iterator()  {\n        return new ListIterator();\n    }\n\n    // an iterator, doesn't implement remove() since it's optional\n    private class ListIterator implements Iterator<Item> {\n        private Node current = first;\n\n        public boolean hasNext()  { return current != null;                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next;\n            return item;\n        }\n    }\n\n    public static void main(String[] args) {\n        Queue_Linked_List<Integer> queue = new Queue_Linked_List<Integer>();\n\tqueue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n\tSystem.out.println(\"(\" + queue.size() + \" left on queue)\");\n\tSystem.out.println(\"Dequeued 1 item off the Queue\");\n        queue.dequeue();\n        System.out.println(\"(\" + queue.size() + \" left on queue)\");\n\tSystem.out.println(queue.toString());\n    }\n}\n\n/* Output\n   (3 left on queue)\n   Dequeued 1 item off the Queue\n   (2 left on queue)\n   2 3\n*/\n"
}
