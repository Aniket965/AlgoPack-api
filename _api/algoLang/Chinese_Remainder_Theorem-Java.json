{
  "mainALGO": "/*\n * If the problem is :\n * 1->\t\tx ≡ 2 mod 3\n * 2->\t\tx ≡ 3 mod 4\n * 3->\t\tx ≡ 4 mod 5\n *\n * then the divisor array in the driver function will be : {3, 4, 5}\n * and the remainder array will be : {2, 3, 4}\n *\n * Therefore the program output is : 59 (Minimum number that satisifies 1, 2, 3).\n */\n\nimport java.lang.*;\n\nclass Chinese_Remainder_Theorem {\n\t//Inverse calculation using extended Euclidean Algorithm(Iterative Method)\n\tpublic static long inverse(long a, long m) {\n\t\tlong m0, x0, x1, q, t;\n\t\tm0 = m;\n\t\tx0 = 0;\n\t\tx1 = 1;\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\twhile (a > 1)\n\t\t{\n\t\t\tq = a / m;\n\t\t\tt = m;\n\t\t\tm = a % m;\n\t\t\ta = t;\n\t\t\tt = x0;\n\t\t\tx0 = x1 - q * x0;\n\t\t\tx1 = t;\n\t\t}\n\n\t\tif (x1 < 0)\n\t\t    x1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t//Main Logic function\n\tpublic static long findMinimumDividend(long[] divisor, long[] remainder) {\n        long product, result, partialProduct;\n        int i, len = divisor.length;\n\n        product = 1;\n\n        for (i = 0; i < len; i++)\n            product *= divisor[i];\n\n        result = 0;\n\n        for (i = 0; i < len; i++)\n        {\n            partialProduct = product / divisor[i];\n            result += remainder[i] * inverse(partialProduct, divisor[i]) * partialProduct;\n        }\n        return (result % product);\n    }\n\n\t// Driver function\n\t// Answer for this problem : 3371\n\tpublic static void main(String[] args) {\n\t\tlong result;\n\t\tlong[] divisor = { 3, 4, 5, 7, 11 };\n        long[] remainder = { 2, 3, 1, 4, 5 };\n        result = findMinimumDividend(divisor, remainder);\n        System.out.println(\"Minimum value of dividend is : \" + result);\n\t}\n}\n"
}
