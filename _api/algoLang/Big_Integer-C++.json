{
  "mainALGO": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//Source : https://discuss.codechef.com/questions/82724/way-to-use-big-integer-in-c\n\nconst int base = 1000000000;\nconst int base_digits = 9;\n\nstruct bigint\n{\n    vector<int> a;\n    int sign;\n\n    bigint() : sign(1) { }\n\n    bigint(long long v)\n    {\n        *this = v;\n    }\n\n    bigint(const string &s)\n    {\n        read(s);\n    }\n\n    void operator=(const bigint &v)\n    {\n        sign = v.sign;\n        a = v.a;\n    }\n\n    void operator=(long long v)\n    {\n        sign = 1;\n        if (v < 0)\n            sign = -1, v = -v;\n        for (; v > 0; v = v / base)\n            a.push_back(v % base);\n    }\n\n    bigint operator+(const bigint &v) const\n    {\n        if (sign == v.sign)\n        {\n            bigint res = v;\n\n            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i)\n            {\n                if (i == (int) res.a.size())\n                    res.a.push_back(0);\n                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);\n                carry = res.a[i] >= base;\n                if (carry)\n                    res.a[i] -= base;\n            }\n            return res;\n        }\n        return *this - (-v);\n    }\n\n    bigint operator-(const bigint &v) const\n    {\n        if (sign == v.sign)\n        {\n            if (abs() >= v.abs())\n            {\n                bigint res = *this;\n                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i)\n                {\n                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);\n                    carry = res.a[i] < 0;\n                    if (carry)\n                        res.a[i] += base;\n                }\n                res.trim();\n                return res;\n            }\n            return -(v - *this);\n        }\n        return *this + (-v);\n    }\n\n    void operator*=(int v)\n    {\n        if (v < 0)\n            sign = -sign, v = -v;\n        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i)\n        {\n            if (i == (int) a.size())\n                a.push_back(0);\n            long long cur = a[i] * (long long) v + carry;\n            carry = (int) (cur / base);\n            a[i] = (int) (cur % base);\n        }\n        trim();\n    }\n\n    bigint operator*(int v) const\n    {\n        bigint res = *this;\n        res *= v;\n        return res;\n    }\n\n    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1)\n    {\n        int norm = base / (b1.a.back() + 1);\n        bigint a = a1.abs() * norm;\n        bigint b = b1.abs() * norm;\n        bigint q, r;\n        q.a.resize(a.a.size());\n\n        for (int i = a.a.size() - 1; i >= 0; i--)\n        {\n            r *= base;\n            r += a.a[i];\n            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];\n            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];\n            int d = ((long long) base * s1 + s2) / b.a.back();\n            r -= b * d;\n            while (r < 0)\n                r += b, --d;\n            q.a[i] = d;\n        }\n\n        q.sign = a1.sign * b1.sign;\n        r.sign = a1.sign;\n        q.trim();\n        r.trim();\n        return make_pair(q, r / norm);\n    }\n\n    bigint operator/(const bigint &v) const\n    {\n        return divmod(*this, v).first;\n    }\n\n    bigint operator%(const bigint &v) const\n    {\n        return divmod(*this, v).second;\n    }\n\n    void operator/=(int v)\n    {\n        if (v < 0)\n            sign = -sign, v = -v;\n        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i)\n        {\n            long long cur = a[i] + rem * (long long) base;\n            a[i] = (int) (cur / v);\n            rem = (int) (cur % v);\n        }\n        trim();\n    }\n\n    bigint operator/(int v) const\n    {\n        bigint res = *this;\n        res /= v;\n        return res;\n    }\n\n    int operator%(int v) const\n    {\n        if (v < 0)\n            v = -v;\n        int m = 0;\n        for (int i = a.size() - 1; i >= 0; --i)\n            m = (a[i] + m * (long long) base) % v;\n        return m * sign;\n    }\n\n    void operator+=(const bigint &v)\n    {\n        *this = *this + v;\n    }\n\n    void operator-=(const bigint &v)\n    {\n        *this = *this - v;\n    }\n\n    void operator*=(const bigint &v)\n    {\n        *this = *this * v;\n    }\n\n    void operator/=(const bigint &v)\n    {\n        *this = *this / v;\n    }\n\n    bool operator<(const bigint &v) const\n    {\n        if (sign != v.sign)\n            return sign < v.sign;\n        if (a.size() != v.a.size())\n            return a.size() * sign < v.a.size() * v.sign;\n        for (int i = a.size() - 1; i >= 0; i--)\n            if (a[i] != v.a[i])\n                return a[i] * sign < v.a[i] * sign;\n        return false;\n    }\n\n    bool operator>(const bigint &v) const\n    {\n        return v < *this;\n    }\n\n    bool operator<=(const bigint &v) const\n    {\n        return !(v < *this);\n    }\n\n    bool operator>=(const bigint &v) const\n    {\n        return !(*this < v);\n    }\n\n    bool operator==(const bigint &v) const\n    {\n        return !(*this < v) && !(v < *this);\n    }\n\n    bool operator!=(const bigint &v) const\n    {\n        return *this < v || v < *this;\n    }\n\n    void trim()\n    {\n        while (!a.empty() && !a.back())\n            a.pop_back();\n        if (a.empty())\n            sign = 1;\n    }\n\n    bool isZero() const\n    {\n        return a.empty() || (a.size() == 1 && !a[0]);\n    }\n\n    bigint operator-() const\n    {\n        bigint res = *this;\n        res.sign = -sign;\n        return res;\n    }\n\n    bigint abs() const\n    {\n        bigint res = *this;\n        res.sign *= res.sign;\n        return res;\n    }\n\n    long long longValue() const\n    {\n        long long res = 0;\n        for (int i = a.size() - 1; i >= 0; i--)\n            res = res * base + a[i];\n        return res * sign;\n    }\n\n    friend bigint gcd(const bigint &a, const bigint &b)\n    {\n        return b.isZero() ? a : gcd(b, a % b);\n    }\n\n    friend bigint lcm(const bigint &a, const bigint &b)\n    {\n        return a / gcd(a, b) * b;\n    }\n\n    void read(const string &s)\n    {\n        sign = 1;\n        a.clear();\n        int pos = 0;\n        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+'))\n        {\n            if (s[pos] == '-')\n                sign = -sign;\n            ++pos;\n        }\n        for (int i = s.size() - 1; i >= pos; i -= base_digits)\n        {\n            int x = 0;\n            for (int j = max(pos, i - base_digits + 1); j <= i; j++)\n                x = x * 10 + s[j] - '0';\n            a.push_back(x);\n        }\n        trim();\n    }\n\n    friend istream& operator>>(istream &stream, bigint &v)\n    {\n        string s;\n        stream >> s;\n        v.read(s);\n        return stream;\n    }\n\n    friend ostream& operator<<(ostream &stream, const bigint &v)\n    {\n        if (v.sign == -1)\n            stream << '-';\n        stream << (v.a.empty() ? 0 : v.a.back());\n        for (int i = (int) v.a.size() - 2; i >= 0; --i)\n            stream << setw(base_digits) << setfill('0') << v.a[i];\n        return stream;\n    }\n\n    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits)\n    {\n        vector<long long> p(max(old_digits, new_digits) + 1);\n        p[0] = 1;\n        for (int i = 1; i < (int) p.size(); i++)\n            p[i] = p[i - 1] * 10;\n        vector<int> res;\n        long long cur = 0;\n        int cur_digits = 0;\n        for (int i = 0; i < (int) a.size(); i++)\n        {\n            cur += a[i] * p[cur_digits];\n            cur_digits += old_digits;\n            while (cur_digits >= new_digits)\n            {\n                res.push_back(int(cur % p[new_digits]));\n                cur /= p[new_digits];\n                cur_digits -= new_digits;\n            }\n        }\n        res.push_back((int) cur);\n        while (!res.empty() && !res.back())\n            res.pop_back();\n        return res;\n    }\n\n    typedef vector<long long> vll;\n\n    static vll karatsubaMultiply(const vll &a, const vll &b)\n    {\n        int n = a.size();\n        vll res(n + n);\n        if (n <= 32)\n        {\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    res[i + j] += a[i] * b[j];\n            return res;\n        }\n\n        int k = n >> 1;\n        vll a1(a.begin(), a.begin() + k);\n        vll a2(a.begin() + k, a.end());\n        vll b1(b.begin(), b.begin() + k);\n        vll b2(b.begin() + k, b.end());\n\n        vll a1b1 = karatsubaMultiply(a1, b1);\n        vll a2b2 = karatsubaMultiply(a2, b2);\n\n        for (int i = 0; i < k; i++)\n            a2[i] += a1[i];\n        for (int i = 0; i < k; i++)\n            b2[i] += b1[i];\n\n        vll r = karatsubaMultiply(a2, b2);\n        for (int i = 0; i < (int) a1b1.size(); i++)\n            r[i] -= a1b1[i];\n        for (int i = 0; i < (int) a2b2.size(); i++)\n            r[i] -= a2b2[i];\n\n        for (int i = 0; i < (int) r.size(); i++)\n            res[i + k] += r[i];\n        for (int i = 0; i < (int) a1b1.size(); i++)\n            res[i] += a1b1[i];\n        for (int i = 0; i < (int) a2b2.size(); i++)\n            res[i + n] += a2b2[i];\n        return res;\n    }\n\n    bigint operator*(const bigint &v) const\n    {\n        vector<int> a6 = convert_base(this->a, base_digits, 6);\n        vector<int> b6 = convert_base(v.a, base_digits, 6);\n        vll a(a6.begin(), a6.end());\n        vll b(b6.begin(), b6.end());\n        while (a.size() < b.size())\n            a.push_back(0);\n        while (b.size() < a.size())\n            b.push_back(0);\n        while (a.size() & (a.size() - 1))\n            a.push_back(0), b.push_back(0);\n        vll c = karatsubaMultiply(a, b);\n        bigint res;\n        res.sign = sign * v.sign;\n        for (int i = 0, carry = 0; i < (int) c.size(); i++)\n        {\n            long long cur = c[i] + carry;\n            res.a.push_back((int) (cur % 1000000));\n            carry = (int) (cur / 1000000);\n        }\n        res.a = convert_base(res.a, 6, base_digits);\n        res.trim();\n        return res;\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n    int N;\n    bigint Arr[1010],Num[1010];\n    bigint Sum = 0;\n    cin >> N;\n    for (int i = 0; i < N; ++i)\n        cin >> Arr[i];\n\n    Num[0] = (bigint)1;\n    for (int i = 1; i <= 999; ++i)\n        Num[i] = (bigint)2 * Num[i - 1] + (bigint)1;\n\n    for (int i = 0; i < N; ++i)\n    {\n        if ( Arr[i] == 1 )\n            Sum = Num[i] - Sum;\n    }\n    cout << Sum << endl;\n    return 0;\n}\n"
}
