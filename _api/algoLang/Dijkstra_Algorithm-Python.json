{
  "mainALGO": "'''\n\tDijkstra's algorithm for weighted undirected graph\n'''\n\nfrom collections import deque\n\nclass Dijkstra:\n    def __init__(self, graph):\n        self.vertex_visited = list()\n        self.distance = {}\n        self.graph = graph\n        self.source = None\n        self.queue_size = 0\n        self.min_queue = deque()\n\n    def initialise(self):\n        self.vertex_visited = list()\n        self.distance = {}\n        #Initialize vertex cost\n        for k,v in self.graph.iteritems():\n            if k == self.source:\n                self.distance.update({k:0})\n            else:\n                self.distance.update({k:float('inf')})\n\n        #Store source vetex and cost\n        for k,v in self.graph[self.source].iteritems():\n            self.priorityQueue({k:v})\n\n    def priorityQueue(self,weight):\n        self.min_queue.append(weight)\n        self.queue_size = self.queue_size + 1\n        self.heapify(self.queue_size)\n\n\n    def heapify(self,i):\n        while i/2 > 0:\n            if self.min_queue[i].values() <= self.min_queue[i/2].values():\n                temp = self.min_queue[i]\n                self.min_queue[i] = self.min_queue[i/2]\n                self.min_queue[i/2] = temp\n            i = i/2\n\n    def del_min(self):\n        popped = self.min_queue[1]\n        self.min_queue[1] = self.min_queue[self.queue_size] #Assign last element to first\n        self.queue_size = self.queue_size - 1;\n        self.min_queue.pop()\n        self.re_heapify(1)\n        return popped\n\n    def re_heapify(self, i):\n        while 2 * i <= self.queue_size:\n            mc = self.min_node(i)\n            if self.min_queue[mc].values() < self.min_queue[i].values():\n                temp = self.min_queue[i]\n                self.min_queue[i] = self.min_queue[mc]\n                self.min_queue[mc] = temp\n            i = mc\n\n    def min_node(self, i):\n        if (2 * i + 1) > self.queue_size:\n            return 2 * i;\n        else:\n            if self.min_queue[2 * i].values() < self.min_queue[2 * i + 1].values():\n                return 2 * i\n            else:\n                return 2 * i +1\n\n    def minDistance(self, source):\n        self.source = source\n        self.min_queue.append({self.source:0}) #Insert source vertex into pq and make its distance as 0.\n        self.initialise() # Reset values for new source\n        while len(self.min_queue) > 1:\n            vertex = self.del_min() #Pop out minimum distance vertex from minimum priority queue\n            if vertex not in self.vertex_visited:\n                self.vertex_visited.append(vertex)\n                for parentNode, parentCost in vertex.iteritems():\n                    for adjVertex, adjCost in self.graph[parentNode].iteritems():\n                        if adjVertex not in self.distance:\n                            self.distance.update({adjVertex:adjCost})\n                        else:\n                            #Compare\n                            if self.distance[adjVertex] > (self.distance[parentNode] + adjCost):\n                                self.distance[adjVertex] = self.distance[parentNode] + adjCost\n                        self.priorityQueue({adjVertex:adjCost}) #Add to minimum priority queue\n        return self.distance\n\n\n\n#Graph stored as adjacent list\ng = { 'A': {'C': 9, 'B': 7, 'F': 14},\n      'B': {'A': 7, 'C': 10, 'D': 15},\n      'C': {'A': 9, 'B': 10, 'D': 11, 'F': 2},\n      'D': {'E': 6, 'B': 15, 'C': 11},\n      'E': {'F': 9, 'D': 6},\n      'F': {'C': 2, 'A': 14, 'E': 9}\n    }\n\ndijkstra = Dijkstra(g)\nprint dijkstra.minDistance('A')\nprint dijkstra.minDistance('E')\n\n'''\nOutput\n-------\n{'A': 0, 'C': 9, 'B': 7, 'E': 20, 'D': 20, 'F': 11}\n{'A': 26, 'C': 17, 'B': 21, 'E': 0, 'D': 6, 'F': 9}\n\n'''\n"
}
