{
  "mainALGO": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nstatic const bool LOG_ENABLED = true;\n\n\n// naive method to compute sa\nvector<int> naive(const string &raw)\n{\n    vector< string > v;\n    for (int i = 0; i < raw.size(); ++i)\n        v.push_back(raw.substr(i));\n    sort(v.begin(), v.end());\n\n    vector<int> result(raw.size());\n    for (size_t i = 0; i<v.size(); ++i)\n        result[i] = raw.size() - v[i].size();\n    return result;\n}\n\n\nvector<int> build_sa(const string& raw)\n{\n    vector<int> bukkit(max(size_t(CHAR_MAX), raw.size()));\n    vector<int> sa(raw.size());\n    vector<int> x(raw.size() * 2 , INT_MAX); // trick to avoid x[i + step] outbounds. Here INT_MAX should be larger than N\n\n    // The next 6 lines are stable bukkit sort(keyword=raw[i], result: sa and x)\n    for (size_t i = 0; i < raw.size(); ++i)\n        ++bukkit[x[i] = raw[i]];\n    for (size_t i = 1; i < bukkit.size(); ++i)\n        bukkit[i] += bukkit[i-1];\n    for (int i = raw.size() - 1; i >= 0; --i)\n        sa[--bukkit[raw[i]]] = i;\n    for (int step = 1; step < raw.size(); step *= 2)\n    {\n        if (LOG_ENABLED)\n        {\n            cout << \"========== Step=\" << step << \" ==========\";\n            cout << endl;\n            cout << \"Pre SA:\" << endl;\n            for (int i = 0; i < raw.size(); ++i)\n                cout << sa[i] << \" \";\n            cout << endl;\n        }\n        vector<int> new_sa;\n        // the 2nd keyword of position N - step, ... must be smallest\n        for (size_t i = raw.size() - step; i < raw.size(); ++i)\n            new_sa.push_back(i);\n        // Then, for each elements that could be 2nd keyword, keep its original order with position sa[i] - step\n        for (size_t i = 0; i< raw.size(); ++i)\n            if (sa[i] >= step)\n                new_sa.push_back(sa[i] - step);\n        if (LOG_ENABLED)\n        {\n            cout << \"SA sorted by 2nd keyword:\" << endl;\n            for (int i = 0; i < raw.size(); ++i)\n                cout << new_sa[i] << \" \";\n            cout << endl;\n        }\n        fill(bukkit.begin(), bukkit.end(), 0);\n\n        // The next 9 lines perform stable bukkit sort(keyword: x[new_sa[i]] [the first keyword], result: sa)\n        for (size_t i = 0; i < new_sa.size(); ++i)\n        {\n            if (LOG_ENABLED)\n                cout << \"Adding to bukkit \" << x[new_sa[i]] << endl;\n            bukkit[x[new_sa[i]]]++;\n        }\n\n        for (size_t i = 1; i < bukkit.size(); ++i)\n            bukkit[i] += bukkit[i-1];\n\n        for (int i = new_sa.size() - 1; i >= 0; --i)\n            sa[--bukkit[x[new_sa[i]]]] = new_sa[i];\n\n        if (LOG_ENABLED)\n        {\n            cout << \"Post SA:\" << endl;\n            for (int i = 0; i < new_sa.size(); ++i)\n                cout << sa[i] << \" \";\n            cout << endl;\n        }\n\n        // To rebuild x from sa\n        // Need decide the number based on whether two key pairs are identical,\n        // Two identical key pairs (10, 10) should be assigned with the same number in next iteration\n        vector<int> newx = x;\n        int p = 0;\n        newx[sa[0]] = 0;\n        for (int i = 1; i<sa.size(); ++i)\n            newx[sa[i]] = ((x[sa[i]] == x[sa[i-1]]) && (x[sa[i] + step] == x[sa[i-1]+step])) ? p : ++p;\n        x = newx;\n        if (LOG_ENABLED)\n        {\n            cout << \"p= \" << p << endl;\n            for (size_t i = 0; i < raw.size(); ++i)\n                cout << \"x[\" << i << \"] = \" << x[i] << endl;\n            cout << endl;\n        }\n        // All different, exit\n        if (p == raw.size() - 1) break;\n    }\n    return sa;\n\n}\n\n\n// For test\nvoid test_one()\n{\n    string s;\n    for (int i = 0; i < 100; ++i)\n        s.push_back('A' + rand() % 10);\n\n    vector<int> good = build_sa(s), bad = naive(s);\n    bool ok = true;\n    if (good.size() != bad.size())\n        ok = false;\n    else\n        for (size_t i = 0; i < good.size(); ++i)\n            if (good[i] != bad[i])\n                ok = false;\n\n    if (ok)\n        cout << \"OK!\" << endl;\n    else\n    {\n        cout << \"Failed for \" << s << endl;\n        for (size_t i = 0; i < good.size(); ++i)\n            cout << good[i] << '\\t';\n        cout << endl;\n        for (size_t i = 0; i < bad.size(); ++i)\n            cout << bad[i] << '\\t';\n        cout << endl;\n    }\n}\n\nint main()\n{\n    // For Internal test\n    //for (int i=0; i<10000; ++i)\n        //test_one();\n    string s;\n    // testcase: abaab\n    cin >> s;\n    vector<int> sa = build_sa(s);\n    for (size_t i = 0; i < sa.size(); ++i)\n        cout << sa[i] << \" \";\n\n    return 0;\n}\n"
}
