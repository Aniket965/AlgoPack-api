{
  "mainALGO": "# Prim's algorithm is a greedy algorithm that\n# finds a minimum spanning tree\n# for a weighted undirected graph.\n#\n# Time complexity: O(m * n)\n\n# Input Format:\n# First line has two integers, denoting the number of nodes in the graph and\n# denoting the number of edges in the graph.\n# The next  lines each consist of three space separated integers,\n# where  and  denote the two nodes between which the undirected edge\n# exists, denotes the length of edge between the corresponding nodes.\n\n# Output Format:\n# Single integer denoting the weight of MST\n\ndef popmin(pqueue):\n    lowest = 1000\n    keylowest = None\n    for key in pqueue:\n        if pqueue[key] < lowest:\n            lowest = pqueue[key]\n            keylowest = key\n    del pqueue[keylowest]\n    return keylowest\n\ndef prim(graph, root):\n    pred = {} # pair {vertex: predecesor in MST}\n    key = {}  # keep track of minimum weight for each vertex\n    pqueue = {} # priority queue implemented as dictionary\n\n    for v in graph:\n        pred[v] = -1\n        key[v] = 1000\n    key[root] = 0\n    for v in graph:\n        pqueue[v] = key[v]\n\n    while pqueue:\n        u = popmin(pqueue)\n        for v in graph[u]: # all neighbors of v\n            if v in pqueue and graph[u][v] < key[v]:\n                pred[v] = u\n                key[v] = graph[u][v]\n                pqueue[v] = graph[u][v]\n    return pred\n\ngraph = {\n            0 : {1:6, 2:8},\n            1 : {4:11},\n            2 : {3:9},\n            3 : {},\n            4 : {5:3},\n            5 : {2:7, 3:4}\n        }\n\npred = prim(graph, 0)\nfor v in pred: print \"%s: %s\" % (v, pred[v])\n\n# Output format:\n# 0: -1\n# 1: 0\n# 2: 0\n# 3: 2\n# 4: 1\n# 5: 4\n"
}
