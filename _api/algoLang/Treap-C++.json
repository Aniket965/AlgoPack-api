{
  "mainALGO": "/**\n\tImplementation of treap data structure\n\tInsert function inserts item\n\tFind returns true if searching item is in treap, else false\n\n\tTime: O(log Size)\n\tMemory: O(Size)\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct node {\n\tint x, y;\n\tnode *l, *r;\n\tnode() {}\n\tnode(int x) : x(x), y(rand()), l(NULL), r(NULL) {}\n};\n\ntypedef node* pnode;\n\npnode merge(pnode a, pnode b) {\n\tif (!a) return b;\n\tif (!b) return a;\n\tif (a -> y > b -> y) {\n\t\ta -> r = merge(a -> r, b);\n\t\treturn a;\n\t}\n\tb -> l = merge(a, b -> l);\n\treturn b;\n}\n\nvoid split(pnode t, int x, pnode &a, pnode &b) {\n\tif (!t)\n\t\treturn void(a = b = NULL);\n\tif (t -> x >= x) {\n\t\tsplit(t -> l, x, a, t -> l);\n\t\tb = t;\n\t} else {\n\t\tsplit(t -> r, x - t -> x, t -> r, b);\n\t\ta = t;\n\t}\n}\n\nbool find(pnode &t, int x) {\n\tif (!t) return false;\n\tif (t -> x == x) return true;\n\tif (t -> x < x)\n\t\treturn find(t -> r, x);\n\treturn find(t -> l, x);\n}\n\nvoid insert(pnode &t, int x) {\n\tif (find(t, x)) return;\n\tpnode a, b;\n\tsplit(t, x, a, b);\n\tt = merge(merge(a, new node(x)), b);\n}\n\nint main() {\n\tsrand(time(0));\n\tpnode t = NULL;\n\tvector <int> toInsert = {1, 2, 3, 6, 15};\n\tvector <int> toFind = {1, 2, 15, 4, 7, 6};\n\tfor (int i = 0; i < toInsert.size(); ++i)\n\t\tinsert(t, toInsert[i]);\n\tcout << boolalpha;\n\tfor (int i = 0; i < toFind.size(); ++i)\n\t\tcout << \"Searching \" << toFind[i] << \" -> \" << find(t, toFind[i]) << endl;\n}\n\n/* Output\n\tSearching 1 -> true\n\tSearching 2 -> true\n\tSearching 15 -> true\n\tSearching 4 -> false\n\tSearching 7 -> false\n\tSearching 6 -> true\n*/\n"
}
