{
  "mainALGO": "\n// C++ implementation of Prim's Algorithm to find the Minimum Spanning tree for a weighted, connected and undirected graph.\n\n#include <iostream>\n#include <climits>\n#define n 6\nusing namespace std;\n\n// Printing the MST\nvoid printMST(int a[n], int b[n], int weight[n])\n{\n    int Minweight = 0; // Weight of Minimum spanning tree\n    for (int i = 0; i < n - 1; i++)\n    {\n        cout << \"Edge: \" << a[i] << \"-\" << b[i] << \" \"\n             << \"cost: \" << weight[i] << endl;\n        Minweight += weight[i];\n    }\n    cout << \"Minimum Weight is \" << Minweight << endl; // Printing the weight of MINIMUM SPANNING TREE\n}\n\nvoid prim(int cost[n][n]) // Function performing prim's algorithm\n{\n    int u, v, k = 0, counti = 0;\n    int visited[n] = { 0 }; // Array containing all the nodes, Initialize with zero as they are not included in MST\n    int a[n]; // Array containing the first nodes of all the edges present in MST\n    int b[n]; // Array containing the first nodes of all the edges present in MST\n    int weight[n]; // Array containing the weights of the edges present in MST\n    int minimum;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if (cost[i][j] == 0) //  If i and j nodes are not adjacent\n                cost[i][j] = INT_MAX; // Then, initialize them as INFINITE\n\n    visited[0] = 1; // Including the first vertex in MST\n\n    while(counti < n-1)\n    {\n        minimum = INT_MAX; // Initializing minimum as INFINITE\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (visited[i] != 0 && cost[i][j] < minimum) // If the first node is not in MST yet, traverse through all the edges connected through it\n                {\n                    minimum = cost[i][j]; // To find the minimum cost edge\n                    u = i; // First node of determined edge\n                    v = j; // Second node of determined edge\n                }\n            }\n        }\n\n        if (visited[u] == 0 || visited[v] == 0) // If the node is not yet included in MST, then include it in MST\n        {\n            a[k] = u; // Store first node in array\n            b[k] = v; // Store second node in array\n            weight[k] = cost[u][v]; // Store the determined edge's weight in array\n            counti++;\n            k++;\n            visited[v] = 1; // Vertex included in MST\n        }\n\n        cost[u][v] = cost[v][u] = INT_MAX; // Edges getting included in MST will be given the weight of INFINITE\n    }\n\n    printMST(a, b, weight); // Printing the MST\n}\n\n// Driver program to test above function\nint main()\n{\n\n/* Let us create the following graph\n\n     (1)____1___(2)\n    /  \\       /  \\\n   3    4     4    6\n  /      \\   /      \\\n /        \\ /        \\\n(0)___5___(5)____5___(3)\n \\         |         /\n  \\        |        /\n   \\       |       /\n    \\      2      /\n     6     |     8\n      \\    |    /\n       \\   |   /\n        \\  |  /\n         \\ | /\n          (4)\n\n\n*/\n    int cost[n][n] = {\n        { 0, 3, 0, 0, 6, 5 },\n        { 3, 0, 1, 0, 0, 4 },\n        { 0, 1, 0, 6, 0, 4 },\n        { 0, 0, 6, 0, 8, 5 },\n        { 6, 0, 0, 8, 0, 2 },\n        { 5, 4, 4, 5, 2, 0 }\n    };\n\n    prim(cost); // Calling prim function\n    return 0;\n}\n\n/*\nOutput :\nEdge: 0-1 cost: 3\nEdge: 1-2 cost: 1\nEdge: 1-5 cost: 4\nEdge: 5-4 cost: 2\nEdge: 5-3 cost: 5\nMinimum Weight is 15\n*/\n"
}
