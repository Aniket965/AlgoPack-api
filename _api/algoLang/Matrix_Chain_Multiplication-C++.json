{
  "mainALGO": "                                                                     /*DESCRIPTION*/\n\n/*Let us define the problem as trying determine the order of multiplication M1*M2*M3*...*Mn using parentheses to denote the order.\n\n  So the basic way to look at this problem in a Dynamic Programming fashion is as follows:-\n\n- We can separate this multiplication into two sets (M1*M2*...*Mj) * (M(j+1)*...*Mn). Thus, the solution at this level comes down to how to choose j to minimize the\n  cost of multiplication.In this case, we would choose j so that M(j+1) is the matrix with the smallest number of rows)\n\n -But, to brute-force this, we need to know how to optimally parentesize each of the sub multiplication chains. Thus, we have a smaller problem at hand.\n  This goes iteratively downwards till we have only two matrices within brackets, at which point we can calculate the flops required directly.\n\n- We now have a big recursive solution at hand where many solutions need to be recalculated,\n\n  eg. for A1*...*A5 given in book, we have these 5 possible solutions\n(A1 (A2 (A3 A4))) ,\n(A1 ((A2 A3) A4)) ,\n((A1 A2) (A3 A4)) ,\n((A1 (A2 A3)) A4) ,\n(((A1 A2) A3) A4).\n\nYou can see that the cost of A3*A4 is required for the calculation of the overall cost in both the first and third solution. It makes sense to store the\ncost of A3*A4 when we first calculate it so that it need not be recalculated. For larger matrix chains, we can store the overall minimal cost directly and\nretrieve it from memory(n^2 table)(this is memorization). Thus, we don't need to go down the recursion the second time.\n*/\n\n/*The technique we have used is called Memorization*/\n\n\n                                                          /*SOURCE CODE*/\n\n#include <iostream>\n#include <cstdlib>\n#include <limits.h>\n\n#define SZ 10\n\nusing namespace std;\n\nint table[SZ][SZ];\n\nint P[] = {10, 20, 30, 40, 30};\n\nint MCM(int i, int j)\n{\n    if(i == j)\n        return 0;\n\n    int min = INT_MAX;\n\n    for(int k = i; k < j; k++)\n    {\n\t    if(table[i][k] == 0)\n\t\t\ttable[i][k] = MCM(i, k);\n\n\t\tif(table[k+1][j] == 0)\n\t\t\ttable[k+1][j] = MCM(k+1, j);\n\n\t\tint sum = table[i][k] + table[k+1][j] + P[i-1] * P[j] * P[k];\n\t    if(sum < min)\n\t       min = sum;\n    }\n\n\ttable[i][j] = min;\n\treturn min;\n}\n\nint main()\n{\n    int size = sizeof(P)/sizeof(P[0]);\n\n\tcout << \"Minimum number of mutiplications is \" << MCM(1, size-1);\n\n\treturn 0;\n}\n\n\n                                                                    /*OUTPUT DESCRIPTION*/\n/*\n              P = {10, 20, 30, 40, 30},\n              dimensions of matrix [1] = 10X20,\n              dimensions of matrix [2] = 20X30,\n              dimensions of matrix [3] = 30X40,\n              dimensions of matrix [4] = 40X30\n\n\n         This is how table[][] matrix will look like\n\n                0 6000 18000 30000\n                0 0    24000 48000\n                0 0    0     36000\n                0 0    0     0\n\n                                     ,where table[1][size-1]=30000 is the answer.\n*/\n"
}
