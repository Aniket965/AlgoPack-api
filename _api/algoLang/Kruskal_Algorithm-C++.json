{
  "mainALGO": "// C++ implementation of Kruskal's Algorithm to find the Minimum Spanning tree for a weighted, connected and undirected graph.\n\n#include <iostream>\n#include <climits>\n#define n 6\nint parent[n]; // Parent array to hold the parent nodes of each node in the graph\n\nusing namespace std;\n\nvoid printMST(int a[n], int b[n], int weight[n]) // Printing the MST\n{\n    int Minweight = 0; // Weight of Minimum spanning tree\n    for (int i = 0; i < n - 1; i++)\n    {\n        cout << \"Edge: \" << a[i] << \"-\" << b[i] << \" \"\n             << \"cost: \" << weight[i] << endl;\n        Minweight += weight[i];\n    }\n    cout << \"Minimum Weight is \" << Minweight << endl; // Printing the weight of MINIMUM SPANNING TREE\n}\n\nint findParent(int node) // Function to determine the parent node\n{\n    while(parent[node] >= 0)\n        node = parent[node];\n\n    return node;\n}\n\n/* \"findParentPathCompression\" is an alternative for \"findParent\" which is more efficient.\n * We use a technique called \"path compression\" here.\n * With path compression, we destroy the structure of the tree, and only focus on which group a node is in.\n */\n\nint findParentPathCompression(int node)\n{\n    if(node == parent[node]) return node;\n    return parent[node] = findParentPathCompression(parent[node]);\n}\n\n\nvoid kruskal(int cost[n][n]) // Function performing Kruskal's algorithm\n{\n    fill_n(parent, n, -1);\n    int u, v, k = 0, count = 0;\n    int firstNode, secondNode;\n    int a[n]; // Array containing the first nodes of all the edges present in MST\n    int b[n]; // Array containing the second nodes of all the edges present in MST\n    int weight[n]; // Array containing the weights of the edges present in MST\n    int minimum;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if (cost[i][j] == 0) //  If i and j nodes are not adjacent\n                cost[i][j] = INT_MAX; // Then, initialize their weight as INFINITE\n\n    while(count < n-1)\n    {\n        minimum = INT_MAX; // Initializing minimum as INFINITE\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (cost[i][j] < minimum)\n                {\n                    minimum = cost[i][j]; // find the minimum cost edge\n                    firstNode = i; // First node of determined edge\n                    secondNode = j; // Second node of determined edge\n                }\n            }\n        }\n\n        u = findParent(firstNode);\n        v = findParent(secondNode);\n\n\n        if (u != v) // If parents of both the nodes are different, no circuit is being formed\n        {\n            parent[v] = u;\n            a[k] = firstNode; // Store first node in array\n            b[k] = secondNode; // Store second node in array\n            weight[k] = cost[firstNode][secondNode]; // Store the determined edge's weight in array\n            count++;\n            k++;\n        }\n\n        cost[firstNode][secondNode] = cost[secondNode][firstNode] = INT_MAX; // Edges getting included in MST will be given the weight of INFINITE\n    }\n\n    printMST(a, b, weight); // Printing the MST\n}\n\n// Driver program to test above function\nint main()\n{\n\n/* Let the given graph is :\n\n     (1)____1___(2)\n    /  \\       /  \\\n   3    4     4    6\n  /      \\   /      \\\n /        \\ /        \\\n(0)___5___(5)____5___(3)\n \\         |         /\n  \\        |        /\n   \\       |       /\n    \\      2      /\n     6     |     8\n      \\    |    /\n       \\   |   /\n        \\  |  /\n         \\ | /\n          (4)\n*/\n\n    int cost[n][n] = {\n        { 0, 3, 0, 0, 6, 5 },\n        { 3, 0, 1, 0, 0, 4 },\n        { 0, 1, 0, 6, 0, 4 },\n        { 0, 0, 6, 0, 8, 5 },\n        { 6, 0, 0, 8, 0, 2 },\n        { 5, 4, 4, 5, 2, 0 }\n    };\n\n    kruskal(cost);\n    return 0;\n}\n\n/*\nOutput :\n Edge: 0-1 cost: 3\n Edge: 1-2 cost: 1\n Edge: 1-5 cost: 4\n Edge: 5-4 cost: 2\n Edge: 5-3 cost: 5\n Minimum Weight is 15\n*/\n"
}
